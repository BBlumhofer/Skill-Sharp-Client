using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Opc.Ua;
using Opc.Ua.Client;

namespace UAClient.Client
{
    public class RemoteSkill : BaseRemoteCallable
    {
        private readonly RemoteServer _remoteServer;
        private System.Collections.Generic.List<string>? _availableStates;
        private NodeId? _stateMachineNode;
        private NodeId? _currentStateNode;
        private NodeId? _startMethodNode;
        private NodeId? _resetMethodNode;
        private NodeId? _stopMethodNode;
        private NodeId? _abortMethodNode;

        public NodeId? StateMachineNode => _stateMachineNode;
        public NodeId? CurrentStateNode => _currentStateNode;
        public NodeId? StartMethodNode => _startMethodNode;
        public NodeId? ResetMethodNode => _resetMethodNode;
        public NodeId? StopMethodNode => _stopMethodNode;
        public NodeId? AbortMethodNode => _abortMethodNode;

        public RemoteSkill(string name, NodeId baseNodeId, UaClient client, RemoteServer remoteServer) : base(name, baseNodeId, client)
        {
            _remoteServer = remoteServer;
        }

        public async Task<NodeId?> FindMethodNodeRecursive(Session session, NodeId startNode, string methodName)
        {
            // Try fast path: translate common paths to NodeId via server-side TranslateBrowsePaths
            try
            {
                var try1 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { methodName });
                if (try1 != null) return try1;
                var try2 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "StateMachine", methodName });
                if (try2 != null) return try2;
                var try3 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "SkillExecution", "StateMachine", methodName });
                if (try3 != null) return try3;
            }
            catch { }

            var browser = new Browser(session)
            {
                BrowseDirection = BrowseDirection.Forward,
                // restrict browsing to HasComponent relationships to avoid wide hierarchical walks
                ReferenceTypeId = ReferenceTypeIds.HasComponent,
                NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
            };
            var queue = new Queue<NodeId>();
            var visited = new HashSet<string>(); // use string form to compare NodeIds safely
            queue.Enqueue(startNode);
            visited.Add(startNode.ToString());
            int inspected = 0;
            const int MaxInspected = 1000; // defensive cutoff to avoid pathological long searches

            while (queue.Count > 0)
            {
                var node = queue.Dequeue();
                if (++inspected > MaxInspected) break;
                ReferenceDescriptionCollection refs = null;
                try
                {
                    refs = await browser.BrowseAsync(node);
                }
                catch { }

                if (refs == null) continue;

                foreach (var r in refs)
                {
                    try
                    {
                    if (r?.NodeId == null) continue;
                        // Check for method-like nodes
                        if (r.NodeClass == NodeClass.Method)
                        {
                            var name = r.DisplayName?.Text ?? r.BrowseName?.Name;
                            if (!string.IsNullOrEmpty(name) && string.Equals(name, methodName, StringComparison.OrdinalIgnoreCase))
                            {
                                var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                                return UaHelpers.ToNodeId(expanded, session);
                            }
                        }

                        // enqueue objects/variables to look deeper
                        if (r.NodeClass == NodeClass.Object || r.NodeClass == NodeClass.Variable)
                        {
                            var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                            var childId = UaHelpers.ToNodeId(expanded, session);
                            if (childId != null)
                            {
                                var key = childId.ToString();
                                if (!visited.Contains(key))
                                {
                                    visited.Add(key);
                                    queue.Enqueue(childId);
                                }
                            }
                        }
                    }
                    catch { }
                }
            }

            return null;
        }

        

        public async Task WriteParameterAsync(string parameterName, object value)
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            // prefer searching inside ParameterSet if present
            NodeId? paramRoot = await FindNodeByBrowseNameRecursive(session, BaseNodeId, "ParameterSet");
            var varNode = paramRoot != null ? await FindVariableNodeRecursive(session, paramRoot, parameterName)
                                           : await FindVariableNodeRecursive(session, BaseNodeId, parameterName);
            if (varNode == null)
            {
                UAClient.Common.Log.Warn($"RemoteSkill '{Name}': parameter '{parameterName}' not found under {BaseNodeId}");
                return;
            }
            UAClient.Common.Log.Info($"RemoteSkill '{Name}': writing parameter {parameterName} -> {value}");
            // Use UaClient helper if available
            try
            {
                await RemoteServerClient.WriteNodeAsync(varNode.ToString(), value);
            }
            catch (ServiceResultException sre) when (sre.StatusCode == StatusCodes.BadOutOfRange)
            {
                // Attempt to read EURange or other metadata to help diagnosis
                try
                {
                    var eurangeNode = await FindNodeByBrowseNameRecursive(session, varNode, "EURange");
                    object? eurangeVal = null;
                    if (eurangeNode != null)
                    {
                        var dv = await session.ReadValueAsync(eurangeNode, System.Threading.CancellationToken.None);
                        eurangeVal = dv.Value;
                    }
                    UAClient.Common.Log.Warn($"RemoteSkill '{Name}': failed to write parameter {parameterName}: BadOutOfRange; attempted value={value}; EURange={eurangeVal}");
                }
                catch (Exception ex)
                {
                    UAClient.Common.Log.Warn($"RemoteSkill '{Name}': failed to write parameter {parameterName}: BadOutOfRange (and reading EURange failed): {ex.Message}");
                }
                throw;
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"RemoteSkill '{Name}': failed to write parameter {parameterName}: {ex.Message}");
            }
        }

        public async Task<string?> WaitForNextStateAsync(SubscriptionManager subMgr, TimeSpan timeout)
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            var stateNode = await FindVariableNodeRecursive(session, BaseNodeId, "CurrentState");
            if (stateNode == null)
            {
                UAClient.Common.Log.Warn($"RemoteSkill '{Name}': CurrentState node not found under {BaseNodeId}");
                return null;
            }

            // read initial state
            string initial = "";
            try
            {
                var dv = await session.ReadValueAsync(stateNode, System.Threading.CancellationToken.None);
                initial = dv.Value?.ToString() ?? "";
            }
            catch { }

            var tcs = new TaskCompletionSource<string?>(TaskCreationOptions.RunContinuationsAsynchronously);
            MonitoredItem? mi = null;
            try
            {
                mi = await subMgr.AddMonitoredItemAsync(stateNode, async (m, e) =>
                {
                    try
                    {
                        var dv = await session.ReadValueAsync(stateNode, System.Threading.CancellationToken.None);
                        var val = dv.Value?.ToString();
                        if (val != initial)
                        {
                            tcs.TrySetResult(val);
                        }
                    }
                    catch { }
                });

                var completed = await Task.WhenAny(tcs.Task, Task.Delay(timeout));
                if (completed == tcs.Task)
                {
                    return await tcs.Task;
                }
                return null;
            }
            finally
            {
                if (mi != null) await subMgr.RemoveMonitoredItemAsync(mi);
            }
        }

        private async Task<NodeId?> FindVariableNodeRecursive(Session session, NodeId startNode, string variableName)
        {
            // Try translate-based fast paths
            try
            {
                var t1 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { variableName });
                if (t1 != null) return t1;
                var t2 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "ParameterSet", variableName });
                if (t2 != null) return t2;
                var t3 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "Monitoring", variableName });
                if (t3 != null) return t3;
                var t4 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "SkillExecution", "StateMachine", variableName });
                if (t4 != null) return t4;
            }
            catch { }

            var browser = new Browser(session)
            {
                BrowseDirection = BrowseDirection.Forward,
                ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                // include Objects as well so we can traverse through Object nodes to find nested Variables
                NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable)
            };
            var queue = new Queue<NodeId>();
            queue.Enqueue(startNode);

            while (queue.Count > 0)
            {
                var node = queue.Dequeue();
                ReferenceDescriptionCollection refs = null;
                try { refs = await browser.BrowseAsync(node); } catch { }
                if (refs == null) continue;
                foreach (var r in refs)
                {
                    try
                    {
                        if (r?.NodeId == null) continue;
                        if (r.NodeClass == NodeClass.Variable)
                        {
                            var name = r.DisplayName?.Text ?? r.BrowseName?.Name;
                            if (!string.IsNullOrEmpty(name) && string.Equals(name, variableName, StringComparison.OrdinalIgnoreCase))
                            {
                                var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                                return UaHelpers.ToNodeId(expanded, session);
                            }
                        }

                        if (r.NodeClass == NodeClass.Object || r.NodeClass == NodeClass.Variable)
                        {
                            var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                            var childId = UaHelpers.ToNodeId(expanded, session);
                            if (childId != null) queue.Enqueue(childId);
                        }
                    }
                    catch { }
                }
            }
            return null;
        }

        public async Task<int?> GetStateAsync()
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            // use cached current state node when available
            NodeId? vid = _currentStateNode;
            if (vid == null)
            {
                // look for CurrentState or State variable anywhere under the skill
                vid = await FindVariableNodeRecursive(session, BaseNodeId, "CurrentState")
                      ?? await FindVariableNodeRecursive(session, BaseNodeId, "State");
            }
            if (vid == null) return null;
            try
            {
                var dv = await session.ReadValueAsync(vid, System.Threading.CancellationToken.None);
                var val = dv?.Value;
                if (val == null)
                {
                    // Diagnostic: CurrentState variable exists but has no Value. Try alternative locations:
                    try
                    {
                        // 1) If CurrentState node is an Object, try to find a child variable named StateNumber or State
                        NodeId? fallback = null;
                        if (_currentStateNode != null)
                        {
                            fallback = await FindVariableNodeRecursive(session, _currentStateNode, "StateNumber")
                                       ?? await FindVariableNodeRecursive(session, _currentStateNode, "State");
                        }
                        // 2) Try StateNumber under the StateMachine node
                        if (fallback == null && _stateMachineNode != null)
                        {
                            fallback = await FindVariableNodeRecursive(session, _stateMachineNode, "StateNumber")
                                       ?? await FindVariableNodeRecursive(session, _stateMachineNode, "State");
                        }

                        if (fallback != null)
                        {
                            var dv2 = await session.ReadValueAsync(fallback, System.Threading.CancellationToken.None);
                            var v2 = dv2?.Value;
                            if (v2 is uint u2) return (int)u2;
                            if (v2 is int ii) return ii;
                            if (v2 is ushort us2) return (int)us2;
                            if (v2 is short s2) return (int)s2;
                            // sometimes StateNumber is presented as string
                            var name2 = v2 is LocalizedText lt2 ? lt2.Text : v2?.ToString();
                            if (!string.IsNullOrEmpty(name2))
                            {
                                try
                                {
                                    var enumVal2 = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), name2, true);
                                    return (int)enumVal2;
                                }
                                catch { }
                            }
                        }

                        // As last resort, try reading BrowseName/DisplayName of the CurrentState node (it could be an object representing the state)
                        try
                        {
                            var node = await session.ReadNodeAsync(vid);
                            var disp = node?.DisplayName?.Text ?? node?.BrowseName?.Name;
                            if (!string.IsNullOrEmpty(disp))
                            {
                                try
                                {
                                    var enumVal3 = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), disp, true);
                                    return (int)enumVal3;
                                }
                                catch { }
                            }
                        }
                        catch { }
                    }
                    catch { }

                    return null;
                }
                // numeric states
                if (val is int i) return i;
                if (val is uint ui) return (int)ui;
                if (val is short s) return (int)s;
                if (val is ushort us) return (int)us;
                // LocalizedText or string names
                var name = val is LocalizedText lt ? lt.Text : val.ToString();
                if (!string.IsNullOrEmpty(name))
                {
                    try
                    {
                        var enumVal = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), name, true);
                        return (int)enumVal;
                    }
                    catch { }
                }
            }
            catch { }
            return null;
        }

        /// <summary>
        /// Determine if skill is finite based on available states (contains 'Completed').
        /// Fallback to FinalResultData heuristic when available states are unknown.
        /// </summary>
        public bool IsFinite
        {
            get
            {
                if (_availableStates != null && _availableStates.Count > 0)
                {
                    try { UAClient.Common.Log.Info($"RemoteSkill '{Name}': AvailableStates count={_availableStates.Count}"); } catch { }
                    foreach (var s in _availableStates)
                    {
                        if (string.Equals(s, "Completed", StringComparison.OrdinalIgnoreCase) ||
                            string.Equals(s, "Completing", StringComparison.OrdinalIgnoreCase))
                        {
                            return true;
                        }
                    }
                    return false;
                }
                try { UAClient.Common.Log.Info($"RemoteSkill '{Name}': AvailableStates unknown, FinalResultData.Count={FinalResultData?.Count ?? 0}"); } catch { }
                return FinalResultData != null && FinalResultData.Count > 0;
            }
        }

        private async System.Threading.Tasks.Task<NodeId?> FindNodeByBrowseNameRecursive(Session session, NodeId startNode, string browseName)
        {
            // Try translate-based fast paths
            try
            {
                var t1 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { browseName });
                if (t1 != null) return t1;
                var t2 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "SkillExecution", browseName });
                if (t2 != null) return t2;
                var t3 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "StateMachine", browseName });
                if (t3 != null) return t3;
            }
            catch { }

            var browser = new Browser(session)
            {
                BrowseDirection = BrowseDirection.Forward,
                ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
            };
            var queue = new System.Collections.Generic.Queue<NodeId>();
            queue.Enqueue(startNode);

            while (queue.Count > 0)
            {
                var node = queue.Dequeue();
                ReferenceDescriptionCollection refs = null;
                try { refs = await browser.BrowseAsync(node); } catch { }
                if (refs == null) continue;
                foreach (var r in refs)
                {
                    try
                    {
                        if (r?.NodeId == null) continue;
                        var name = r.DisplayName?.Text ?? r.BrowseName?.Name;
                        var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                        var childId = UaHelpers.ToNodeId(expanded, session);
                        if (childId == null) continue;
                        if (!string.IsNullOrEmpty(name) && string.Equals(name, browseName, StringComparison.OrdinalIgnoreCase))
                        {
                            return childId;
                        }
                        if (r.NodeClass == NodeClass.Object || r.NodeClass == NodeClass.Variable)
                        {
                            queue.Enqueue(childId);
                        }
                    }
                    catch { }
                }
            }
            return null;
        }

        public override async System.Threading.Tasks.Task SetupSubscriptionsAsync(SubscriptionManager subscriptionManager, bool createSubscriptions = false)
        {
            // allow base to collect FinalResultData (and optionally create subscriptions)
            await base.SetupSubscriptionsAsync(subscriptionManager, createSubscriptions);
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");

            // Try to locate SkillExecution -> StateMachine -> CurrentState / AvailableStates
            try
            {
                var skillExec = await FindNodeByBrowseNameRecursive(session, BaseNodeId, "SkillExecution");
                if (skillExec != null)
                {
                    var stateMachine = await FindNodeByBrowseNameRecursive(session, skillExec, "StateMachine");
                    if (stateMachine != null)
                    {
                        _stateMachineNode = stateMachine;
                        // CurrentState node
                        var current = await FindNodeByBrowseNameRecursive(session, stateMachine, "CurrentState");
                        if (current != null) _currentStateNode = current;

                        // AvailableStates node/value
                        var avail = await FindNodeByBrowseNameRecursive(session, stateMachine, "AvailableStates");
                        if (avail != null)
                        {
                            try
                            {
                                var dv = await session.ReadValueAsync(avail, System.Threading.CancellationToken.None);
                                var val = dv.Value;
                                var list = new System.Collections.Generic.List<string>();
                                if (val is string[] sa) list.AddRange(sa);
                                else if (val is object[] oa)
                                {
                                    foreach (var o in oa) list.Add(o?.ToString() ?? "");
                                }
                                else if (val != null)
                                {
                                    list.Add(val.ToString() ?? "");
                                }
                                if (list.Count > 0) _availableStates = list;
                                // Diagnostic logging: show exactly what AvailableStates contains
                                try
                                {
                                    UAClient.Common.Log.Info($"RemoteSkill '{Name}': AvailableStates read ({list.Count}): {string.Join(", ", list)}");
                                }
                                catch { }
                            }
                            catch { }
                        }

                        // subscribe to current state changes if available
                        if (_currentStateNode != null && createSubscriptions)
                        {
                            try
                            {
                                await subscriptionManager.SubscribeDataChangeAsync(this, new[]{ _currentStateNode });
                                // Log current state node and its current value for diagnostics
                                try
                                {
                                    var cv = await session.ReadValueAsync(_currentStateNode, System.Threading.CancellationToken.None);
                                    UAClient.Common.Log.Info($"RemoteSkill '{Name}': CurrentState node={_currentStateNode} initialValue=({cv.Value?.GetType().Name ?? "null"}) {cv.Value}");
                                }
                                catch { }
                            }
                            catch
                            {
                                // ignore
                            }
                        }

                        // (no fallback search here; rely on structured lookup under SkillExecution/StateMachine)

                        // preload commonly used method nodes (Start/Reset/Stop/Abort) using TranslateBrowsePaths first
                        // parallel preload commonly used method nodes (Start/Reset/Stop/Abort) using TranslateBrowsePaths first
                        try
                        {
                            var startTask = Task.Run(async () =>
                            {
                                return await SessionBrowseCache.TranslatePathAsync(session, stateMachine, new[] { "Start" })
                                       ?? await SessionBrowseCache.TranslatePathAsync(session, BaseNodeId, new[] { "Start" })
                                       ?? await SessionBrowseCache.TranslatePathAsync(session, BaseNodeId, new[] { "SkillExecution", "StateMachine", "Start" })
                                       ?? await FindMethodNodeRecursive(session, stateMachine, "Start");
                            });

                            var resetTask = Task.Run(async () =>
                            {
                                return await SessionBrowseCache.TranslatePathAsync(session, stateMachine, new[] { "Reset" })
                                       ?? await SessionBrowseCache.TranslatePathAsync(session, BaseNodeId, new[] { "Reset" })
                                       ?? await SessionBrowseCache.TranslatePathAsync(session, BaseNodeId, new[] { "SkillExecution", "StateMachine", "Reset" })
                                       ?? await FindMethodNodeRecursive(session, stateMachine, "Reset");
                            });

                            var stopTask = Task.Run(async () =>
                            {
                                return await SessionBrowseCache.TranslatePathAsync(session, stateMachine, new[] { "Stop" })
                                       ?? await SessionBrowseCache.TranslatePathAsync(session, BaseNodeId, new[] { "Stop" })
                                       ?? await FindMethodNodeRecursive(session, stateMachine, "Stop");
                            });

                            var abortTask = Task.Run(async () =>
                            {
                                return await SessionBrowseCache.TranslatePathAsync(session, stateMachine, new[] { "Abort" })
                                       ?? await SessionBrowseCache.TranslatePathAsync(session, BaseNodeId, new[] { "Abort" })
                                       ?? await FindMethodNodeRecursive(session, stateMachine, "Abort");
                            });

                            await Task.WhenAll(startTask, resetTask, stopTask, abortTask);
                            _startMethodNode = startTask.Result;
                            _resetMethodNode = resetTask.Result;
                            _stopMethodNode = stopTask.Result;
                            _abortMethodNode = abortTask.Result;
                        }
                        catch { }
                    }
                }
            }
            catch { }
        }

        public async Task<bool> WaitForStateAsync(Common.SkillStates desired, TimeSpan timeout)
        {
            var sw = System.Diagnostics.Stopwatch.StartNew();
            while (sw.Elapsed < timeout)
            {
                var st = await GetStateAsync();
                if (st != null && st == (int)desired) return true;
                await Task.Delay(500);
            }
            return false;
        }

        public async Task StartAsync(params object[] inputs)
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            // Check current state and skip Start if already running
            try
            {
                var st = await GetStateAsync();
                if (st != null && st == (int)Common.SkillStates.Running)
                {
                    UAClient.Common.Log.Info($"RemoteSkill '{Name}': Start skipped, skill already Running (state={st})");
                    return;
                }
            }
            catch { }

            // Prefer cached Start method node id to avoid repeated searches
            NodeId? methodId = _startMethodNode;
            if (methodId == null)
            {
                UAClient.Common.Log.Info($"RemoteSkill '{Name}': attempting to find Start method under {BaseNodeId}");
                methodId = await FindMethodNodeRecursive(session, BaseNodeId, "Start");
            }

            if (methodId == null)
            {
                UAClient.Common.Log.Warn($"RemoteSkill '{Name}': Start method not found");
                throw new InvalidOperationException("Start method not found for skill");
            }

            UAClient.Common.Log.Info($"RemoteSkill '{Name}': calling Start method {methodId} (base={BaseNodeId})");
            try
            {
                await session.CallAsync(BaseNodeId, methodId, System.Threading.CancellationToken.None, inputs);
            }
            catch (ServiceResultException ex)
            {
                // Log full exception (includes StatusCode and potential diagnostic info)
                try
                {
                    UAClient.Common.Log.Warn($"RemoteSkill '{Name}': Start method call failed: {ex}");
                    // If available, log server-side DiagnosticInfo from the exception Data
                    if (ex.Data != null)
                    {
                        try { UAClient.Common.Log.Debug($"Start call exception Data: {string.Join(";", ex.Data.Keys.Cast<object>().Select(k => k.ToString() + ":" + ex.Data[k]?.ToString()))}"); } catch { }
                    }
                }
                catch { }
                throw;
            }
        }

        /// <summary>
        /// High-level skill invocation.
        /// Writes parameters (if provided), optionally attempts to reset skill before start when halted/completed,
        /// starts the skill and optionally waits for completion. Returns FinalResultData when waitForCompletion==true.
        /// </summary>
        public async Task<IDictionary<string, object?>> ExecuteAsync(IDictionary<string, object?>? parameters = null,
            bool waitForCompletion = true,
            bool resetAfterCompletion = true,
            bool resetBeforeIfHalted = true,
            TimeSpan? timeout = null,
            SubscriptionManager? subscriptionManager = null)
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            timeout ??= TimeSpan.FromSeconds(30);

            // write parameters if provided
            if (parameters != null)
            {
                foreach (var kv in parameters)
                {
                    try { await WriteParameterAsync(kv.Key, kv.Value ?? ""); } catch (Exception ex) { UAClient.Common.Log.Warn($"RemoteSkill '{Name}': failed to write parameter {kv.Key}: {ex.Message}"); }
                }
            }

            // reset before if requested and skill is halted or completed
                try
                {
                        var st = await GetStateAsync();
                        if (resetBeforeIfHalted && (st == (int)Common.SkillStates.Halted || st == (int)Common.SkillStates.Completed || st == (int)Common.SkillStates.Suspended))
                        {
                            UAClient.Common.Log.Info($"RemoteSkill '{Name}': attempting Reset before start (state={st})");
                            // Prefer Reset on the StateMachine node if available
                            NodeId? resetTarget = _stateMachineNode ?? BaseNodeId;
                            var resetMethod = await FindMethodNodeRecursive(session, resetTarget, "Reset")
                                              ?? await FindMethodNodeRecursive(session, BaseNodeId, "Reset");
                            if (resetMethod != null)
                            {
                                UAClient.Common.Log.Info($"RemoteSkill '{Name}': invoking Reset on {resetTarget} method {resetMethod}");
                                try
                                {
                                    await session.CallAsync(resetTarget, resetMethod, System.Threading.CancellationToken.None);
                                }
                                catch (ServiceResultException rex)
                                {
                                    try
                                    {
                                        UAClient.Common.Log.Warn($"RemoteSkill '{Name}': Reset call failed: {rex}");
                                    }
                                    catch { }
                                    throw;
                                }
                                // wait for ready (prefer subscription-based wait if a manager was provided earlier)
                                bool ok = false;
                                if (subscriptionManager != null)
                                {
                                    var sw = System.Diagnostics.Stopwatch.StartNew();
                                    var curState = await GetStateAsync();
                                    if (curState != null && curState == (int)Common.SkillStates.Ready) ok = true;
                                    while (!ok && sw.Elapsed < timeout.Value)
                                    {
                                        var remaining = timeout.Value - sw.Elapsed;
                                        var waitSlice = remaining.TotalSeconds > 5 ? TimeSpan.FromSeconds(5) : remaining;
                                        var nxt = await WaitForNextStateAsync(subscriptionManager, waitSlice);
                                        if (!string.IsNullOrEmpty(nxt))
                                        {
                                            if (string.Equals(nxt, "Ready", StringComparison.OrdinalIgnoreCase)) { ok = true; break; }
                                            try { var ev = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), nxt, true); if (ev == Common.SkillStates.Ready) { ok = true; break; } } catch { }
                                        }
                                    }
                                }
                                else
                                {
                                    ok = await WaitForStateAsync(Common.SkillStates.Ready, timeout.Value);
                                }
                                if (!ok) UAClient.Common.Log.Warn($"RemoteSkill '{Name}': reset before did not reach Ready within timeout");
                                else UAClient.Common.Log.Info($"RemoteSkill '{Name}': Reset before reached Ready");
                            }
                            else
                            {
                                UAClient.Common.Log.Warn($"RemoteSkill '{Name}': Reset method not found for pre-reset (target={resetTarget})");
                            }
                        }
                }
                catch (Exception ex) { UAClient.Common.Log.Warn($"RemoteSkill '{Name}': exception during pre-reset: {ex.Message}"); }

            // ensure skill is ready
            var cur = await GetStateAsync();
            if (cur == null || cur != (int)Common.SkillStates.Ready)
            {
                var curName = cur != null ? Enum.IsDefined(typeof(Common.SkillStates), cur.Value) ? ((Common.SkillStates)cur.Value).ToString() : cur.Value.ToString() : "null";
                throw new InvalidOperationException($"RemoteSkill '{Name}' is not in Ready state (current={cur} / {curName})");
            }

            // start with retry+reset+backoff on specific status codes
            int attempts = 0;
            const int maxAttempts = 3;
            while (true)
            {
                attempts++;
                try
                {
                    UAClient.Common.Log.Info($"RemoteSkill '{Name}': calling Start() (pre-state={cur}, attempt={attempts})");
                    await StartAsync();
                    // After calling Start, ensure the skill actually transitions to Running
                    try
                    {
                        bool ran = false;
                        if (subscriptionManager != null)
                        {
                            var next = await WaitForNextStateAsync(subscriptionManager, TimeSpan.FromSeconds(5));
                            if (!string.IsNullOrEmpty(next))
                            {
                                if (string.Equals(next, "Running", StringComparison.OrdinalIgnoreCase)) ran = true;
                                else
                                {
                                    try
                                    {
                                        var enumVal = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), next, true);
                                        ran = enumVal == Common.SkillStates.Running;
                                    }
                                    catch { }
                                }
                            }
                        }
                        else
                        {
                            ran = await WaitForStateAsync(Common.SkillStates.Running, TimeSpan.FromSeconds(5));
                        }

                        if (!ran)
                        {
                            UAClient.Common.Log.Warn($"RemoteSkill '{Name}': Start did not transition to Running within 5s, treating as BadInvalidState to trigger reset+retry");
                            throw new ServiceResultException(StatusCodes.BadInvalidState);
                        }
                    }
                    catch (ServiceResultException) { throw; }
                    catch (Exception ex)
                    {
                        UAClient.Common.Log.Warn($"RemoteSkill '{Name}': exception while verifying Running state after Start: {ex.Message}");
                    }
                    break; // success
                }
                catch (ServiceResultException ex) when (ex.StatusCode == StatusCodes.BadStateNotActive || ex.StatusCode == StatusCodes.BadInvalidState)
                {
                    UAClient.Common.Log.Warn($"RemoteSkill '{Name}': Start failed with {ex.StatusCode} ({ex.Message}), attempt={attempts}; exception={ex}");
                    if (attempts >= maxAttempts)
                    {
                        UAClient.Common.Log.Warn($"RemoteSkill '{Name}': reached max start attempts ({maxAttempts}), giving up");
                        throw;
                    }
                    try
                    {
                        // attempt a Reset on the StateMachine node if available
                        NodeId? resetTarget = _stateMachineNode ?? BaseNodeId;
                        var resetMethod = await FindMethodNodeRecursive(session, resetTarget, "Reset")
                                          ?? await FindMethodNodeRecursive(session, BaseNodeId, "Reset");
                        // prefer cached reset method id when available
                        var cachedReset = _resetMethodNode ?? resetMethod;
                            if (cachedReset != null)
                            {
                                UAClient.Common.Log.Info($"RemoteSkill '{Name}': invoking Reset on {resetTarget} method {resetMethod} (attempt={attempts})");
                                try
                                {
                                    await session.CallAsync(resetTarget, cachedReset, System.Threading.CancellationToken.None);
                                }
                                catch (ServiceResultException rex)
                                {
                                     try
                                     {
                                        UAClient.Common.Log.Warn($"RemoteSkill '{Name}': Reset call failed during retry: {rex}");
                                     }
                                     catch { }
                                    // fall through to backoff and retry attempts
                                }
                            // wait for ready
                            var ok = await WaitForStateAsync(Common.SkillStates.Ready, timeout.Value);
                            if (!ok)
                            {
                                UAClient.Common.Log.Warn($"RemoteSkill '{Name}': reset did not reach Ready within timeout (attempt={attempts})");
                            }
                        }
                        else
                        {
                            UAClient.Common.Log.Warn($"RemoteSkill '{Name}': Reset method not found for retry (target={resetTarget}) (attempt={attempts})");
                        }
                    }
                    catch (Exception rex)
                    {
                        UAClient.Common.Log.Warn($"RemoteSkill '{Name}': exception during reset+retry: {rex.Message}");
                    }
                    // backoff before next attempt
                    var delayMs = 250 * attempts; // 250ms, 500ms, 750ms
                    await Task.Delay(delayMs);
                    continue;
                }
            }

            if (!waitForCompletion)
            {
                UAClient.Common.Log.Info($"RemoteSkill '{Name}': waitForCompletion=false — entering monitoring loop until Completed or Halted");
                try
                {
                    while (true)
                    {
                        var stLoop = await GetStateAsync();
                        if (stLoop != null)
                        {
                            if (stLoop == (int)Common.SkillStates.Completed || stLoop == (int)Common.SkillStates.Halted)
                            {
                                UAClient.Common.Log.Info($"RemoteSkill '{Name}': observed terminal state {stLoop}");
                                break;
                            }
                        }
                        // print monitoring values while waiting
                        try { await PrintMonitoringAsync(session); } catch { }
                        await Task.Delay(500);
                    }
                }
                catch (Exception ex)
                {
                    UAClient.Common.Log.Warn($"RemoteSkill '{Name}': exception in monitoring loop: {ex.Message}");
                }
                // proceed to read final result data below
            }

            // wait for completion
            if (IsFinite)
            {
                // finite skills should reach Completing/Completed
                bool completed = false;
                if (subscriptionManager != null)
                {
                    var sw = System.Diagnostics.Stopwatch.StartNew();
                    var curState = await GetStateAsync();
                    if (curState != null && curState == (int)Common.SkillStates.Completed) completed = true;
                    while (!completed && sw.Elapsed < timeout.Value)
                    {
                        var remaining = timeout.Value - sw.Elapsed;
                        var waitSlice = remaining.TotalSeconds > 5 ? TimeSpan.FromSeconds(5) : remaining;
                        var nxt = await WaitForNextStateAsync(subscriptionManager, waitSlice);
                        if (!string.IsNullOrEmpty(nxt))
                        {
                            if (string.Equals(nxt, "Completed", StringComparison.OrdinalIgnoreCase)) { completed = true; break; }
                            try { var ev = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), nxt, true); if (ev == Common.SkillStates.Completed) { completed = true; break; } } catch { }
                        }
                    }
                }
                else
                {
                    completed = await WaitForStateAsync(Common.SkillStates.Completed, timeout.Value);
                }
                if (!completed)
                {
                    UAClient.Common.Log.Warn($"RemoteSkill '{Name}': did not reach Completed within timeout");
                }
            }
            else
            {
                // continuous skills: no Completing/Completed; expect transition from Running -> Halting -> Halted
                // wait for Halting or Halted
                bool reachedHalting = false;
                bool reachedHalted = false;
                if (subscriptionManager != null)
                {
                    var sw = System.Diagnostics.Stopwatch.StartNew();
                    var curState = await GetStateAsync();
                    if (curState != null && (curState == (int)Common.SkillStates.Halting || curState == (int)Common.SkillStates.Halted))
                    {
                        if (curState == (int)Common.SkillStates.Halting) reachedHalting = true;
                        if (curState == (int)Common.SkillStates.Halted) reachedHalted = true;
                    }
                    while (!reachedHalting && sw.Elapsed < timeout.Value)
                    {
                        var remaining = timeout.Value - sw.Elapsed;
                        var waitSlice = remaining.TotalSeconds > 5 ? TimeSpan.FromSeconds(5) : remaining;
                        var nxt = await WaitForNextStateAsync(subscriptionManager, waitSlice);
                        if (!string.IsNullOrEmpty(nxt))
                        {
                            if (string.Equals(nxt, "Halting", StringComparison.OrdinalIgnoreCase)) { reachedHalting = true; break; }
                            try { var ev = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), nxt, true); if (ev == Common.SkillStates.Halting) { reachedHalting = true; break; } } catch { }
                        }
                    }
                    if (!reachedHalting)
                    {
                        // try waiting for Halted directly
                        sw = System.Diagnostics.Stopwatch.StartNew();
                        while (!reachedHalted && sw.Elapsed < timeout.Value)
                        {
                            var remaining = timeout.Value - sw.Elapsed;
                            var waitSlice = remaining.TotalSeconds > 5 ? TimeSpan.FromSeconds(5) : remaining;
                            var nxt = await WaitForNextStateAsync(subscriptionManager, waitSlice);
                            if (!string.IsNullOrEmpty(nxt))
                            {
                                if (string.Equals(nxt, "Halted", StringComparison.OrdinalIgnoreCase)) { reachedHalted = true; break; }
                                try { var ev = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), nxt, true); if (ev == Common.SkillStates.Halted) { reachedHalted = true; break; } } catch { }
                            }
                        }
                        if (!reachedHalted)
                        {
                            UAClient.Common.Log.Warn($"RemoteSkill '{Name}': continuous skill did not reach Halting/Halted within timeout");
                        }
                    }
                    else
                    {
                        // if halting observed, wait until halted
                        var sw2 = System.Diagnostics.Stopwatch.StartNew();
                        while (!reachedHalted && sw2.Elapsed < timeout.Value)
                        {
                            var remaining = timeout.Value - sw2.Elapsed;
                            var waitSlice = remaining.TotalSeconds > 5 ? TimeSpan.FromSeconds(5) : remaining;
                            var nxt = await WaitForNextStateAsync(subscriptionManager, waitSlice);
                            if (!string.IsNullOrEmpty(nxt))
                            {
                                if (string.Equals(nxt, "Halted", StringComparison.OrdinalIgnoreCase)) { reachedHalted = true; break; }
                                try { var ev = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), nxt, true); if (ev == Common.SkillStates.Halted) { reachedHalted = true; break; } } catch { }
                            }
                        }
                        if (!reachedHalted) UAClient.Common.Log.Warn($"RemoteSkill '{Name}': did not reach Halted after Halting within timeout");
                    }
                }
                else
                {
                    var reachedHaltingLocal = await WaitForStateAsync(Common.SkillStates.Halting, timeout.Value);
                    if (!reachedHaltingLocal)
                    {
                        var reachedHaltedLocal = await WaitForStateAsync(Common.SkillStates.Halted, timeout.Value);
                        if (!reachedHaltedLocal)
                        {
                            UAClient.Common.Log.Warn($"RemoteSkill '{Name}': continuous skill did not reach Halting/Halted within timeout");
                        }
                    }
                    else
                    {
                        var halted = await WaitForStateAsync(Common.SkillStates.Halted, timeout.Value);
                        if (!halted) UAClient.Common.Log.Warn($"RemoteSkill '{Name}': did not reach Halted after Halting within timeout");
                    }
                }
            }

            // read final result data (parallel reads to reduce roundtrips)
            var outDict = new Dictionary<string, object?>();
            try
            {
                var readTasks = new List<Task<(string key, object? val)>>();
                foreach (var kv in FinalResultData)
                {
                    var key = kv.Key;
                    var node = kv.Value.NodeId;
                    readTasks.Add(Task.Run(async () =>
                    {
                        try
                        {
                            var dv = await session.ReadValueAsync(node, System.Threading.CancellationToken.None);
                            return (key, dv.Value as object);
                        }
                        catch
                        {
                            return (key, (object?)null);
                        }
                    }));
                }

                var results = await Task.WhenAll(readTasks);
                foreach (var r in results)
                {
                    outDict[r.key] = r.val;
                }
            }
            catch { }

            // reset after completion if requested
            if (resetAfterCompletion)
            {
                try
                {
                    // Prefer Reset on the StateMachine node if available
                    NodeId? resetTarget = _stateMachineNode ?? BaseNodeId;
                    var resetMethod = await FindMethodNodeRecursive(session, resetTarget, "Reset")
                                      ?? await FindMethodNodeRecursive(session, BaseNodeId, "Reset");
                    if (resetMethod != null)
                    {
                            try
                            {
                                await session.CallAsync(resetTarget, resetMethod, System.Threading.CancellationToken.None);
                            }
                            catch (ServiceResultException rex)
                            {
                                try { UAClient.Common.Log.Warn($"RemoteSkill '{Name}': post-completion Reset call failed: {rex}"); } catch { }
                            }
                        // wait for Ready after post-reset
                        if (subscriptionManager != null)
                        {
                            var sw = System.Diagnostics.Stopwatch.StartNew();
                            var ready = false;
                            var curState = await GetStateAsync();
                            if (curState != null && curState == (int)Common.SkillStates.Ready) ready = true;
                            while (!ready && sw.Elapsed < timeout.Value)
                            {
                                var remaining = timeout.Value - sw.Elapsed;
                                var waitSlice = remaining.TotalSeconds > 5 ? TimeSpan.FromSeconds(5) : remaining;
                                var nxt = await WaitForNextStateAsync(subscriptionManager, waitSlice);
                                if (!string.IsNullOrEmpty(nxt))
                                {
                                    if (string.Equals(nxt, "Ready", StringComparison.OrdinalIgnoreCase)) { ready = true; break; }
                                    try { var ev = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), nxt, true); if (ev == Common.SkillStates.Ready) { ready = true; break; } } catch { }
                                }
                            }
                        }
                        else
                        {
                            await WaitForStateAsync(Common.SkillStates.Ready, timeout.Value);
                        }
                    }
                }
                catch (Exception ex) { UAClient.Common.Log.Warn($"RemoteSkill '{Name}': exception during post-reset: {ex.Message}"); }
            }

            return outDict;
        }

        public async Task StopAsync()
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            var methodId = await FindMethodNodeRecursive(session, BaseNodeId, "Stop");
            if (methodId == null) return;
            await session.CallAsync(BaseNodeId, methodId, System.Threading.CancellationToken.None);
        }

        private async Task PrintMonitoringAsync(Session session)
        {
            try
            {
                var monRoot = await FindNodeByBrowseNameRecursive(session, BaseNodeId, "Monitoring");
                if (monRoot == null) return;
                var browser = new Browser(session)
                {
                    BrowseDirection = BrowseDirection.Forward,
                    ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                    NodeClassMask = (int)NodeClass.Variable
                };
                ReferenceDescriptionCollection refs = null;
                try { refs = await browser.BrowseAsync(monRoot); } catch { }
                if (refs == null) return;
                foreach (var r in refs)
                {
                    try
                    {
                        if (r?.NodeId == null) continue;
                        if (r.NodeClass != NodeClass.Variable) continue;
                        var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                        var varId = UaHelpers.ToNodeId(expanded, session);
                        if (varId == null) continue;
                        var name = r.DisplayName?.Text ?? r.BrowseName?.Name ?? varId.ToString();
                        object? val = null;
                        try
                        {
                            var dv = await session.ReadValueAsync(varId, System.Threading.CancellationToken.None);
                            val = dv.Value;
                        }
                        catch { }
                        UAClient.Common.Log.Info($"RemoteSkill '{Name}': monitoring {name} = {val}");
                    }
                    catch { }
                }
            }
            catch { }
        }

        public async Task AbortAsync()
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            var methodId = await FindMethodNodeRecursive(session, BaseNodeId, "Abort");
            if (methodId == null) return;
            await session.CallAsync(BaseNodeId, methodId, System.Threading.CancellationToken.None);
        }
    }
}
