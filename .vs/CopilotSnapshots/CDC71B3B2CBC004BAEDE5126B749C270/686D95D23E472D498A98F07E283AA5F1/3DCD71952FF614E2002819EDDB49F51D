using System;
using System.Threading;
using System.Threading.Tasks;
using Opc.Ua;
using Opc.Ua.Client;
using UAClient.Client;
using System.Diagnostics;
using UAClient.Common;

namespace UAClient
{
    class Program
    {
        private static async Task WithTimeout(Task task, TimeSpan timeout)
        {
            var completed = await Task.WhenAny(task, Task.Delay(timeout));
            if (completed == task)
            {
                await task; // propagate exceptions
                return;
            }
            throw new TimeoutException($"Operation timed out after {timeout.TotalSeconds} seconds");
        }

        private static async Task<T> WithTimeout<T>(Task<T> task, TimeSpan timeout)
        {
            var completed = await Task.WhenAny(task, Task.Delay(timeout));
            if (completed == task)
            {
                return await task; // propagate exceptions
            }
            throw new TimeoutException($"Operation timed out after {timeout.TotalSeconds} seconds");
        }
        static async Task<int> Main(string[] args)
        {
            // Install global handlers for unobserved/background exceptions to improve resilience
            TaskScheduler.UnobservedTaskException += (s, e) =>
            {
                try
                {
                    UAClient.Common.Log.Warn($"UnobservedTaskException: {e.Exception?.Message}");
                }
                catch { }
                e.SetObserved();
            };
            AppDomain.CurrentDomain.UnhandledException += (s, e) =>
            {
                try
                {
                    var ex = e.ExceptionObject as Exception;
                    UAClient.Common.Log.Warn($"UnhandledException: {ex?.Message}");
                }
                catch { }
            };

            // Determine if user passed a mode as the first argument (allow shortcuts like "autoready" without URL)
            string? mode = null;
            var defaultUrl = "opc.tcp://localhost:4842";
            string url, username, password;
            if (args.Length > 0 && !string.IsNullOrEmpty(args[0]))
            {
                var first = args[0].Trim();
                if (string.Equals(first, "--skilltest", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(first, "--locktest", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(first, "--autoready", StringComparison.OrdinalIgnoreCase) ||
                    string.Equals(first, "--locktest", StringComparison.OrdinalIgnoreCase))
                {
                    // first arg is a mode token -> use defaults for connection
                    mode = first;
                    url = defaultUrl;
                    username = "orchestrator";
                    password = "orchestrator";
                }
                else
                {
                    url = args.Length > 0 ? args[0] : defaultUrl;
                    username = args.Length > 1 ? args[1] : "orchestrator";
                    password = args.Length > 2 ? args[2] : "orchestrator";
                }
            }
            else
            {
                url = defaultUrl;
                username = "orchestrator";
                password = "orchestrator";
            }

            // Validate URL early to provide a clear error instead of an opaque Uri exception later
            if (!Uri.TryCreate(url, UriKind.Absolute, out var parsedUri))
            {
                Console.Error.WriteLine($"Invalid server URL provided: '{url}'. Please provide a valid absolute URI (e.g. 'opc.tcp://localhost:4842').");
                UAClient.Common.Log.Error($"Invalid server URL provided: '{url}'");
                return 1;
            }

            // use fully-qualified type to avoid namespace resolution issues
            var client = new global::UAClient.Client.UaClient(url, username, password);
            // parse optional command argument (after url/user/pass)
            // Log selected scenario to console for visibility
            var scenario = string.IsNullOrEmpty(mode) ? "default" : mode;
            Console.WriteLine($"Selected scenario: {scenario}");
            // backward-compatible shortcut: existing LockTest runner used when --locktest passed
            if (!string.IsNullOrEmpty(mode) && string.Equals(mode, "--locktest", StringComparison.OrdinalIgnoreCase))
            {
                return await Client.LockTest.Run(url, username, password, args.Length > 4 ? args[4] : "CA-Module");
            }
            try
            {
                // bound connect to avoid hangs
                UAClient.Common.Log.Info("Connecting to OPC UA endpoint...");

                var swTotal = Stopwatch.StartNew();

                var swValidate = Stopwatch.StartNew();
                // measure ValidateAsync indirectly by calling ConnectAsync which includes ValidateAsync
                await WithTimeout(client.ConnectAsync(), TimeSpan.FromSeconds(90));
                swValidate.Stop();
                Console.WriteLine("Connected.");
                Console.WriteLine($"[TIMING] Client.ConnectAsync (includes ValidateAsync, Discovery, Session) elapsed {swValidate.Elapsed.TotalMilliseconds} ms");

                var server = new Client.RemoteServer(client);

                // connect to remote server with timeout (increased to 90s for slow discovery + subscriptions)
                UAClient.Common.Log.Info("Connecting to remote server and discovering modules...");
                var swServer = Stopwatch.StartNew();
                await WithTimeout(server.ConnectAsync(), TimeSpan.FromSeconds(90));
                swServer.Stop();
                Console.WriteLine($"Remote server status: {server.Status}");
                Console.WriteLine($"[TIMING] RemoteServer.ConnectAsync elapsed {swServer.Elapsed.TotalMilliseconds} ms");

                swTotal.Stop();
                Console.WriteLine($"[TIMING] Total initialization elapsed {swTotal.Elapsed.TotalMilliseconds} ms");

                Console.WriteLine("Discovered modules:");
                               // For each module, create RemoteComponent wrappers for discovered methods/objects
                Console.WriteLine();
                Console.WriteLine("Component-level discovery (per module):");
                // Component discovery is now performed automatically by RemoteServer.ConnectAsync
                // Access components via server.Components
                // Wait briefly for components to be populated and copy into a mutable dictionary for fallback additions
                var swComp = Stopwatch.StartNew();
                while (server.Components.Count == 0 && swComp.Elapsed < TimeSpan.FromSeconds(5)) await Task.Delay(200);
                var components = new System.Collections.Generic.Dictionary<string, Client.RemoteComponent>(server.Components, StringComparer.OrdinalIgnoreCase);
                Console.WriteLine($"Discovered {components.Count} components:");
                foreach (var kv in components)
                {
                    Console.WriteLine($"  {kv.Key}");
                }

                // Determine normalized mode (accept with or without leading dashes). Default to "autoready" when not specified.
                string modeNorm = "autoready";
                if (!string.IsNullOrEmpty(mode))
                {
                    modeNorm = mode.TrimStart('-').ToLowerInvariant();
                }
                Console.WriteLine($"Running mode: {modeNorm}");

                // Only discover module when a mode requires it
                Client.RemoteModule? targetModule = null;
                if (modeNorm == "skilltest" || modeNorm == "locktest" || modeNorm == "autoready")
                {
                    if (server.Modules.TryGetValue("CA-Module", out var foundModule)) targetModule = foundModule;
                    else if (server.Modules.Count > 0) targetModule = server.Modules.Values.First();

                    if (targetModule == null)
                    {
                        UAClient.Common.Log.Warn("No module found on server for requested mode");
                        Console.WriteLine("No module found on server for requested mode; exiting.");
                        return 1;
                    }
                }

                // Execute only the passages required for the selected mode
                switch (modeNorm)
                {
                    case "skilltest":
                        {
                            try
                            {
                                try { targetModule.AllowLockFallback = true; } catch { }
                                var session = client.Session ?? throw new InvalidOperationException("No session");

                                // Lock and start module (startup skill)
                                await WithTimeout(targetModule.LockAsync(session), TimeSpan.FromSeconds(10));
                                await WithTimeout(targetModule.StartAsync(reset: true, timeout: TimeSpan.FromSeconds(60)), TimeSpan.FromSeconds(70));

                                // Execute MoveToJointPosition once
                                RemoteComponent robotComp = targetModule.Components["Robot"];
                                RemoteSkill moveSkill = robotComp.SkillSet["MoveToJointPosition"];
                                var rnd = new Random();
                                double RandAngle() => Math.Round(rnd.NextDouble() * 90.0 - 45.0, 2);
                                var parameters = new System.Collections.Generic.Dictionary<string, object?>
                                {
                                    ["SAxisPosition"] = RandAngle(),
                                    ["LAxisPosition"] = RandAngle(),
                                    ["UAxisPosition"] = RandAngle(),
                                    ["RAxisPosition"] = RandAngle(),
                                    ["BAxisPosition"] = RandAngle(),
                                    ["TAxisPosition"] = RandAngle()
                                };

                                var result = await ((dynamic)moveSkill).ExecuteAsync(parameters, waitForCompletion: true, resetAfterCompletion: true, resetBeforeIfHalted: true, timeout: TimeSpan.FromSeconds(120));
                                Console.WriteLine("MoveToJointPosition completed. FinalResultData:");
                                foreach (var kv in result) Console.WriteLine($"  {kv.Key} = {kv.Value}");

                                return 0;
                            }
                            catch (Exception ex)
                            {
                                UAClient.Common.Log.Warn($"Skilltest failed: {ex.Message}");
                                return 1;
                            }
                        }

                    case "locktest":
                        {
                            try
                            {
                                try { targetModule.AllowLockFallback = true; } catch { }
                                var session = client.Session ?? throw new InvalidOperationException("No session");

                                // Ensure module locked and startup skill started (best-effort)
                                await WithTimeout(targetModule.LockAsync(session), TimeSpan.FromSeconds(10));
                                await WithTimeout(targetModule.StartAsync(reset: true, timeout: TimeSpan.FromSeconds(60)), TimeSpan.FromSeconds(70));

                                UAClient.Common.Log.Info("Enabling auto-relock for manual break test (60s)...");
                                await targetModule.EnableAutoRelockAsync();

                                Console.WriteLine("Auto-relock enabled for 60 seconds.");
                                Console.WriteLine("Please break the module lock from the operator console now (or simulate).\nPress ENTER to finish early.");

                                var cts = new CancellationTokenSource();
                                var waitTask = Task.Run(async () =>
                                {
                                    var sw = Stopwatch.StartNew();
                                    while (sw.Elapsed < TimeSpan.FromSeconds(60) && !cts.IsCancellationRequested)
                                    {
                                        try
                                        {
                                            var locked = await targetModule.Lock?.IsLockedAsync(client.Session!);
                                            Console.WriteLine($"[AutoRelock] Locked={locked}");
                                        }
                                        catch { }
                                        await Task.Delay(5000, cts.Token);
                                    }
                                }, cts.Token);

                                var inputTask = Task.Run(() => Console.ReadLine());
                                await Task.WhenAny(waitTask, inputTask);
                                try { cts.Cancel(); } catch { }

                                UAClient.Common.Log.Info("Disabling auto-relock after test window...");
                                try { await targetModule.DisableAutoRelockAsync(); } catch { }

                                return 0;
                            }
                            catch (Exception ex)
                            {
                                UAClient.Common.Log.Warn($"Locktest failed: {ex.Message}");
                                return 1;
                            }
                        }

                    case "autoready":
                    default:
                        {
                            try
                            {
                                try { targetModule.AllowLockFallback = true; } catch { }

                                UAClient.Common.Log.Info("Enabling auto-ready for test window (60s)...");
                                await targetModule.EnableAutoReadyAsync(TimeSpan.FromSeconds(5));

                                Console.WriteLine("Auto-ready enabled for 60 seconds.");
                                Console.WriteLine("Module will be made ready periodically. Press ENTER to finish early.");

                                var cts2 = new CancellationTokenSource();
                                var waitTask2 = Task.Run(async () =>
                                {
                                    var sw = Stopwatch.StartNew();
                                    while (sw.Elapsed < TimeSpan.FromSeconds(60) && !cts2.IsCancellationRequested)
                                    {
                                        try
                                        {
                                            Console.WriteLine($"[AutoReady] IsReady={targetModule.IsReady}");
                                        }
                                        catch { }
                                        await Task.Delay(5000, cts2.Token);
                                    }
                                }, cts2.Token);

                                var inputTask2 = Task.Run(() => Console.ReadLine());
                                await Task.WhenAny(waitTask2, inputTask2);
                                try { cts2.Cancel(); } catch { }

                                UAClient.Common.Log.Info("Disabling auto-ready after test window...");
                                try { await targetModule.DisableAutoReadyAsync(); } catch { }

                                return 0;
                            }
                            catch (Exception ex)
                            {
                                UAClient.Common.Log.Warn($"AutoReady failed: {ex.Message}");
                                return 1;
                            }
                        }
                }


            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Error($"Exception in {nameof(Main)}: {ex.Message}");
                return 1;
            }
            finally
            {
                try { await client.DisconnectAsync(); } catch { }
            }
        }
    }
}
