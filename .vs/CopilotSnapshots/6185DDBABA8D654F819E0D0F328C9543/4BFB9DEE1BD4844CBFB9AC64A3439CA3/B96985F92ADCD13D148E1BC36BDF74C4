using System;
using System.Collections.Generic;
using Opc.Ua;
using Opc.Ua.Client;
using System.Linq;

namespace UAClient.Client
{
    public class RemoteModule
    {
        // If true, allow falling back to the first discovered Lock object when no
        // explicit Lock candidate was found. Default is false (strict mode).
        public bool AllowLockFallback { get; set; } = false;

        public string Name { get; }
        public NodeId BaseNodeId { get; }
        public IDictionary<string, BaseRemoteCallable> Methods { get; } = new Dictionary<string, BaseRemoteCallable>();
        public RemoteLock? Lock { get; private set; }
        public IDictionary<string, RemotePort> Ports { get; } = new Dictionary<string, RemotePort>();
        public IDictionary<string, RemoteStorage> Storages { get; } = new Dictionary<string, RemoteStorage>();
        public IDictionary<string, RemoteComponent> Components { get; } = new Dictionary<string, RemoteComponent>(StringComparer.OrdinalIgnoreCase);
        public IDictionary<string, RemoteSkill> SkillSet { get; } = new Dictionary<string, RemoteSkill>(StringComparer.OrdinalIgnoreCase);
        public IDictionary<string, RemoteVariable> Monitoring { get; } = new Dictionary<string, RemoteVariable>(StringComparer.OrdinalIgnoreCase);
        private IDictionary<NodeId, RemoteVariable> _monitoring_nodes = new Dictionary<NodeId, RemoteVariable>();
        private UaClient _client;
        private RemoteServer _remoteServer;

        public RemoteModule(string name, NodeId baseNodeId, UaClient client, RemoteServer remoteServer)
        {
            Name = name;
            BaseNodeId = baseNodeId;
            _client = client;
            _remoteServer = remoteServer;
        }

        private async System.Threading.Tasks.Task<NodeId?> GetTypeDefinitionAsync(Session session, NodeId nodeId)
        {
            try
            {
                var browser = new Browser(session)
                {
                    BrowseDirection = BrowseDirection.Forward,
                    ReferenceTypeId = ReferenceTypeIds.HasTypeDefinition,
                    IncludeSubtypes = true,
                    NodeClassMask = 0 // any
                };
                var refs = await browser.BrowseAsync(nodeId);
                if (refs != null && refs.Count > 0)
                {
                    var expanded = refs[0].NodeId as ExpandedNodeId ?? new ExpandedNodeId(refs[0].NodeId);
                    return UaHelpers.ToNodeId(expanded, session);
                }
            }
            catch { }
            return null;
        }

        private async System.Threading.Tasks.Task<string?> GetBrowseNameAsync(Session session, NodeId nodeId)
        {
            try
            {
                var readValueIds = new ReadValueIdCollection { new ReadValueId { NodeId = nodeId, AttributeId = Attributes.BrowseName } };
                DataValueCollection results;
                DiagnosticInfoCollection diagnosticInfos;
                session.Read(null, 0, TimestampsToReturn.Neither, readValueIds, out results, out diagnosticInfos);
                if (results != null && results.Count > 0 && results[0].Value != null)
                {
                    var qn = results[0].Value as QualifiedName;
                    return qn?.Name;
                }
            }
            catch { }
            return null;
        }

        private async System.Threading.Tasks.Task<object?> CreateRemoteObjectFromTypeDefinitionAsync(Session session, NodeId nodeId, string name)
        {
            // Define base types by BrowseName
            var machineryItemTypes = new System.Collections.Generic.HashSet<string>
            {
                "TopologyElementType",
                "ComponentType",
                "DeviceType",
                "MachineryItemType",
                "MachineType",
                "StorageSlotType",
                "GripperType",
                "ShuttleType",
                "SafetyType",
                "DoorType",
                "ConveyingAreaType",
                // Machinery specific
                "MachineryItemIdentificationType",
                "MachineIdentificationType",
                "MachineryComponentIdentificationType",
                "MachineryOperationCounterType",
                "MachineryLifetimeCounterType",
                "MachineComponentsType",
                "MachineryItemState_StateMachineType",
                "MachineryOperationModeStateMachineType",
                // IA specific
                "BasicStacklightType",
                "StacklightType",
                "CalibrationTargetType",
                "AcousticSignalType",
                "StackElementType"
            };
            var skillTypes = new System.Collections.Generic.HashSet<string>
            {
                "FiniteSkillType",
                "ContinuousSkillType"
            };

            // Check for Locks  
            NodeId type_def = await GetTypeDefinitionAsync(session, nodeId);
            // If this node is a LockingServicesType, create a single Lock object
            if (await IsTypeOrSubtypeOfAsync(session, nodeId, new System.Collections.Generic.HashSet<string> { "LockingServicesType" }))
            {
                var lockObj = new RemoteLock(name, nodeId);
                await RemoteVariableCollector.AddVariableNodesAsync(session, nodeId, lockObj.NodeMap, lockObj.Variables, true);
                // Populate descriptor and methods
                var desc = new RemoteLockDescriptor { BaseNodeId = nodeId };
                // Enumerate children for methods
                try
                {
                    var browserLock = new Browser(session)
                    {
                        BrowseDirection = BrowseDirection.Forward,
                        ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                        NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                    };
                    var refsLock = await browserLock.BrowseAsync(nodeId);
                    if (refsLock != null)
                    {
                        foreach (var rLock in refsLock)
                        {
                            try
                            {
                                if (rLock?.NodeId == null) continue;
                                var expandedLock = rLock.NodeId as ExpandedNodeId ?? new ExpandedNodeId(rLock.NodeId);
                                var mId = UaHelpers.ToNodeId(expandedLock, session);
                                if (mId == null) continue;
                                var mName = rLock.DisplayName?.Text ?? rLock.BrowseName?.Name ?? mId.ToString();
                                var rm = new RemoteMethod(mName, mId, _client);
                                lockObj.Methods[mName] = rm;
                                lockObj.MethodsNodeMap[mId] = rm;
                                // Map to descriptor and properties
                                if (mName.IndexOf("InitLock", StringComparison.OrdinalIgnoreCase) >= 0) { desc.InitLock = mId; lockObj.InitLock = rm; }
                                if (mName.IndexOf("BreakLock", StringComparison.OrdinalIgnoreCase) >= 0) { desc.BreakLock = mId; lockObj.BreakLock = rm; }
                                if (mName.IndexOf("ExitLock", StringComparison.OrdinalIgnoreCase) >= 0) { desc.ExitLock = mId; lockObj.ExitLock = rm; }
                                if (mName.IndexOf("RenewLock", StringComparison.OrdinalIgnoreCase) >= 0) { desc.RenewLock = mId; lockObj.RenewLock = rm; }
                                if (mName.IndexOf("Skill", StringComparison.OrdinalIgnoreCase) >= 0)
                                {
                                    var rs = new RemoteSkill(mName, mId, _client, _remoteServer);
                                    lockObj.Methods[$"skill:{mName}"] = rs;
                                    lockObj.MethodsNodeMap[mId] = rs;
                                }
                            }
                            catch { }
                        }
                    }
                }
                catch { }
                // Map variables to descriptor
                foreach (var kv in lockObj.Variables)
                {
                    var key = kv.Key ?? "";
                    var nid = kv.Value.NodeId;
                    if (key.IndexOf("Locked", StringComparison.OrdinalIgnoreCase) >= 0) desc.Locked = nid;
                    if (key.IndexOf("LockingUser", StringComparison.OrdinalIgnoreCase) >= 0) desc.LockingUser = nid;
                    if (key.IndexOf("LockingClient", StringComparison.OrdinalIgnoreCase) >= 0) desc.LockingClient = nid;
                    if (key.IndexOf("RemainingLockTime", StringComparison.OrdinalIgnoreCase) >= 0) desc.RemainingLockTime = nid;
                    if (key.IndexOf("CurrentState", StringComparison.OrdinalIgnoreCase) >= 0 || key.IndexOf("State", StringComparison.OrdinalIgnoreCase) >= 0) desc.CurrentState = nid;
                }
                // Set convenience properties
                if (lockObj.Variables.TryGetValue("Locked", out var rvLocked)) lockObj.Locked = rvLocked;
                if (lockObj.Variables.TryGetValue("LockingUser", out var rvUser)) lockObj.LockingUser = rvUser;
                if (lockObj.Variables.TryGetValue("LockingClient", out var rvClient)) lockObj.LockingClient = rvClient;
                if (lockObj.Variables.TryGetValue("RemainingLockTime", out var rvRemaining)) lockObj.RemainingLockTime = rvRemaining;
                if (lockObj.Variables.TryGetValue("CurrentState", out var rvState)) lockObj.CurrentState = rvState;
                lockObj.Descriptor = desc;
                return lockObj;
            }
            // Check for Ports
            else if (await IsTypeOrSubtypeOfAsync(session, nodeId, new System.Collections.Generic.HashSet<string> { "PortType" }))
            {
                var port = new RemotePort(name, nodeId, this);
                await RemoteVariableCollector.AddVariableNodesAsync(session, nodeId, port.NodeMap, port.Variables, true);
                // Attach methods
                try
                {
                    var browser3 = new Browser(session)
                    {
                        BrowseDirection = BrowseDirection.Forward,
                        ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                        NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                    };
                    var refs3 = await browser3.BrowseAsync(nodeId);
                    if (refs3 != null)
                    {
                        foreach (var r3 in refs3)
                        {
                            try
                            {
                                if (r3?.NodeId == null) continue;
                                var expanded3 = r3.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r3.NodeId);
                                var methodId = UaHelpers.ToNodeId(expanded3, session);
                                if (methodId == null) continue;
                                var methodName = r3.DisplayName?.Text ?? r3.BrowseName?.Name ?? methodId.ToString();
                                var rm = new RemoteMethod(methodName, methodId, _client);
                                port.Methods[methodName] = rm;
                                port.MethodsNodeMap[methodId] = rm;
                                if (methodName.IndexOf("Skill", StringComparison.OrdinalIgnoreCase) >= 0)
                                {
                                    var rs = new RemoteSkill(methodName, methodId, _client, _remoteServer);
                                    port.Methods[$"skill:{methodName}"] = rs;
                                    port.MethodsNodeMap[methodId] = rs;
                                }
                            }
                            catch { }
                        }
                    }
                }
                catch { }
                return port;
            }
            // Check for Storages
            else if (await IsTypeOrSubtypeOfAsync(session, nodeId, new System.Collections.Generic.HashSet<string> { "StorageType" }))
            {
                var storage = new RemoteStorage(name, nodeId);
                await RemoteVariableCollector.AddVariableNodesAsync(session, nodeId, storage.NodeMap, storage.Variables, true);
                // Attempt to discover StorageSlot children under the storage
                try
                {
                    var browser = new Browser(session)
                    {
                        BrowseDirection = BrowseDirection.Forward,
                        ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                        NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                    };
                    var refs = await browser.BrowseAsync(nodeId);
                    if (refs != null)
                    {
                        foreach (var r in refs)
                        {
                            try
                            {
                                if (r?.NodeId == null) continue;
                                var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                                var childId = UaHelpers.ToNodeId(expanded, session);
                                if (childId == null) continue;
                                var childName = r.DisplayName?.Text ?? r.BrowseName?.Name ?? childId.ToString();

                                // If the child is a StorageSlot (by browse name or type), create a RemoteStorageSlot
                                var isSlot = false;
                                try
                                {
                                    if (!string.IsNullOrEmpty(r.BrowseName?.Name) && r.BrowseName.Name.IndexOf("StorageSlot", StringComparison.OrdinalIgnoreCase) >= 0)
                                    {
                                        isSlot = true;
                                    }
                                    else
                                    {
                                        isSlot = await IsTypeOrSubtypeOfAsync(session, childId, new System.Collections.Generic.HashSet<string> { "StorageSlotType" });
                                    }
                                }
                                catch { }

                                if (isSlot)
                                {
                                    try
                                    {
                                        var slot = new RemoteStorageSlot(childName, childId);
                                        await RemoteVariableCollector.AddVariableNodesAsync(session, childId, slot.NodeMap, slot.Variables, false);
                                        // add to storage.Slots
                                        try { storage.Slots[childName] = slot; } catch { }
                                    }
                                    catch { }
                                }
                            }
                            catch { }
                        }
                    }
                }
                catch { }

                // Also check for a 'Components' child under the storage (slots may be placed there)
                try
                {
                    var browserC = new Browser(session)
                    {
                        BrowseDirection = BrowseDirection.Forward,
                        ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                        NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                    };
                    var topRefs = await browserC.BrowseAsync(nodeId);
                    if (topRefs != null)
                    {
                        NodeId? compContainerId = null;
                        foreach (var tr in topRefs)
                        {
                            try
                            {
                                var name = tr?.DisplayName?.Text ?? tr?.BrowseName?.Name ?? string.Empty;
                                if (string.Equals(name, "Components", StringComparison.OrdinalIgnoreCase))
                                {
                                    var expanded = tr.NodeId as ExpandedNodeId ?? new ExpandedNodeId(tr.NodeId);
                                    compContainerId = UaHelpers.ToNodeId(expanded, session);
                                    break;
                                }
                            }
                            catch { }
                        }

                        if (compContainerId != null)
                        {
                            var crefs = await browserC.BrowseAsync(compContainerId);
                            if (crefs != null)
                            {
                                foreach (var cr in crefs)
                                {
                                    try
                                    {
                                        if (cr?.NodeId == null) continue;
                                        var expanded = cr.NodeId as ExpandedNodeId ?? new ExpandedNodeId(cr.NodeId);
                                        var compId = UaHelpers.ToNodeId(expanded, session);
                                        if (compId == null) continue;
                                        var compName = cr.DisplayName?.Text ?? cr.BrowseName?.Name ?? compId.ToString();
                                        var isSlot2 = false;
                                        try { isSlot2 = await IsTypeOrSubtypeOfAsync(session, compId, new System.Collections.Generic.HashSet<string> { "StorageSlotType" }); } catch { }
                                        if (isSlot2)
                                        {
                                            try
                                            {
                                                var slot = new RemoteStorageSlot(compName, compId);
                                                await RemoteVariableCollector.AddVariableNodesAsync(session, compId, slot.NodeMap, slot.Variables, false);
                                                try { storage.Slots[compName] = slot; } catch { }
                                            }
                                            catch { }
                                        }
                                    }
                                    catch { }
                                }
                            }
                        }
                    }
                }
                catch { }

                return storage;
            }
            // Check for Machinery Items (Components)
            else if (await IsTypeOrSubtypeOfAsync(session, nodeId, machineryItemTypes))
            {
                var component = new RemoteComponent(name, nodeId, _client, _remoteServer);
                return component;
            }
            // Check for Skills
            else if (await IsTypeOrSubtypeOfAsync(session, nodeId, skillTypes))
            {
                var skill = new RemoteSkill(name, nodeId, _client, _remoteServer);
                return skill;
            }
            return null;
        }

        public async System.Threading.Tasks.Task DiscoverMethodsAsync()
        {
            var session = _client.Session;
            if (session == null) return;

            var visited = new System.Collections.Concurrent.ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
            var queue = new System.Collections.Concurrent.ConcurrentQueue<NodeId>();
            queue.Enqueue(BaseNodeId);
            var dictLock = new object();

            while (queue.TryDequeue(out var node))
            {
                if (node == null) continue;
                var nodeKey = node.ToString();
                if (!visited.TryAdd(nodeKey, true)) continue;

                var browser = new Browser(session)
                {
                    BrowseDirection = BrowseDirection.Forward,
                    ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                    NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                };
                ReferenceDescriptionCollection refs = null;
                try { refs = await browser.BrowseAsync(node); } catch { }
                if (refs == null) continue;

                var tasks = new System.Collections.Generic.List<System.Threading.Tasks.Task>();
                foreach (var r in refs)
                {
                    // process each child reference in parallel
                    tasks.Add(System.Threading.Tasks.Task.Run(async () =>
                    {
                        try
                        {
                            if (r?.NodeId == null) return;
                            var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                            var childId = UaHelpers.ToNodeId(expanded, session);
                            if (childId == null) return;
                            var name = r.DisplayName?.Text ?? childId.ToString() ?? "<unknown>";
                            var browseName = r.BrowseName?.Name ?? "";

                            UAClient.Common.Log.Debug($"RemoteModule '{Name}': discovered child {name} (browse='{browseName}') of class {r.NodeClass}");

                            // Get the child's type definition browse name (if any)
                            string? childTypeBrowseName = null;
                            try
                            {
                                var typeDef = await GetTypeDefinitionAsync(session, childId);
                                if (typeDef != null) childTypeBrowseName = await GetBrowseNameAsync(session, typeDef);
                            }
                            catch { }

                            // If this is a Monitoring container (MonitoringType), collect variables into Monitoring map
                            if (!string.IsNullOrEmpty(childTypeBrowseName) && childTypeBrowseName.IndexOf("MonitoringType", StringComparison.OrdinalIgnoreCase) >= 0
                                || string.Equals(browseName, "Monitoring", StringComparison.OrdinalIgnoreCase))
                            {
                                try
                                {
                                    await RemoteVariableCollector.AddVariableNodesAsync(session, childId, _monitoring_nodes, Monitoring, false);
                                    UAClient.Common.Log.Info($"RemoteModule '{Name}': added Monitoring variables from '{name}' ({Monitoring.Count} vars)");
                                }
                                catch { }
                                return;
                            }

                            // Special handling: if this child is a MachineComponentsType (a container of components), enumerate its children and create components
                            if (!string.IsNullOrEmpty(childTypeBrowseName) && childTypeBrowseName.IndexOf("MachineComponentsType", StringComparison.OrdinalIgnoreCase) >= 0)
                            {
                                try
                                {
                                    var browserCompContainer = new Browser(session)
                                    {
                                        BrowseDirection = BrowseDirection.Forward,
                                        ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                                        NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                                    };
                                    var compRefs = await browserCompContainer.BrowseAsync(childId);
                                    if (compRefs != null)
                                    {
                                        foreach (var cr in compRefs)
                                        {
                                            try
                                            {
                                                if (cr?.NodeId == null) continue;
                                                var exp = cr.NodeId as ExpandedNodeId ?? new ExpandedNodeId(cr.NodeId);
                                                var compId = UaHelpers.ToNodeId(exp, session);
                                                if (compId == null) continue;
                                                var compName = cr.DisplayName?.Text ?? cr.BrowseName?.Name ?? compId.ToString();
                                                var remoteObj = await CreateRemoteObjectFromTypeDefinitionAsync(session, compId, compName);
                                                if (remoteObj != null)
                                                {
                                                    lock (dictLock)
                                                    {
                                                        if (remoteObj is RemotePort port)
                                                        {
                                                            Ports[compName] = port;
                                                            // also expose as RemoteComponent wrapper for component-level access
                                                            try
                                                            {
                                                                var compWrapper = new RemoteComponent(compName, compId, _client, _remoteServer);
                                                                Components[compName] = compWrapper;
                                                            }
                                                            catch { }
                                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': added Port from MachineComponents '{compName}'");
                                                        }
                                                        else if (remoteObj is RemoteStorage storage)
                                                        {
                                                            Storages[compName] = storage;
                                                            try
                                                            {
                                                                var compWrapper = new RemoteComponent(compName, compId, _client, _remoteServer);
                                                                Components[compName] = compWrapper;
                                                            }
                                                            catch { }
                                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': added Storage from MachineComponents '{compName}'");
                                                        }
                                                        else if (remoteObj is RemoteLock rlock)
                                                        {
                                                            Lock = rlock;
                                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': set Lock from MachineComponents '{compName}'");
                                                        }
                                                        else if (remoteObj is RemoteComponent component)
                                                        {
                                                            Components[compName] = component;
                                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': added Component from MachineComponents '{compName}'");
                                                        }
                                                        else if (remoteObj is RemoteSkill skill)
                                                        {
                                                            Methods[compName] = new RemoteMethod(compName, compId, _client);
                                                            Methods[$"skill:{compName}"] = skill;
                                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': added Skill from MachineComponents '{compName}'");
                                                        }
                                                    }
                                                }
                                                else
                                                {
                                                    // fallback: treat as generic component
                                                    var comp = new RemoteComponent(compName, compId, _client, _remoteServer);
                                                    lock (dictLock) { Components[compName] = comp; }
                                                    UAClient.Common.Log.Info($"RemoteModule '{Name}': added Component from MachineComponents (fallback) '{compName}'");
                                                }
                                            }
                                            catch { }
                                        }
                                    }
                                }
                                catch { }
                                return;
                            }

                            // Heuristic: detect Components by checking for common child folders
                            try
                            {
                                var checkBrowser = new Browser(session)
                                {
                                    BrowseDirection = BrowseDirection.Forward,
                                    ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                                    NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                                };
                                var childRefs = await checkBrowser.BrowseAsync(childId);
                                if (childRefs != null && childRefs.Count > 0)
                                {
                                    foreach (var cr in childRefs)
                                    {
                                        var childName = cr?.DisplayName?.Text ?? cr?.BrowseName?.Name ?? string.Empty;
                                        if (string.Equals(childName, "SkillSet", StringComparison.OrdinalIgnoreCase)
                                            || string.Equals(childName, "Monitoring", StringComparison.OrdinalIgnoreCase)
                                            || string.Equals(childName, "MethodSet", StringComparison.OrdinalIgnoreCase)
                                            || string.Equals(childName, "Attributes", StringComparison.OrdinalIgnoreCase)
                                            || string.Equals(childName, "Components", StringComparison.OrdinalIgnoreCase)
                                            || string.Equals(childName, "Resources", StringComparison.OrdinalIgnoreCase))
                                        {
                                            // treat this node as a Component
                                            try
                                            {
                                                var component = new RemoteComponent(name, childId, _client, _remoteServer);
                                                lock (dictLock)
                                                {
                                                    Components[name] = component;
                                                }
                                                UAClient.Common.Log.Info($"RemoteModule '{Name}': heuristic added Component '{name}'");
                                                return;
                                            }
                                            catch { }
                                        }
                                    }
                                }
                            }
                            catch { }

                            // If this is a SkillSet container, enumerate children and create skills
                            if (string.Equals(browseName, "SkillSet", StringComparison.OrdinalIgnoreCase) || string.Equals(name, "SkillSet", StringComparison.OrdinalIgnoreCase) || (!string.IsNullOrEmpty(childTypeBrowseName) && childTypeBrowseName.IndexOf("SkillSetType", StringComparison.OrdinalIgnoreCase) >= 0))
                             {
                                 try
                                 {
                                     var browser2 = new Browser(session)
                                     {
                                         BrowseDirection = BrowseDirection.Forward,
                                         ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                                         NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                                     };
                                     var refs2 = await browser2.BrowseAsync(childId);
                                     if (refs2 != null)
                                     {
                                        foreach (var r2 in refs2)
                                        {
                                            try
                                            {
                                                if (r2?.NodeId == null) continue;
                                                var expanded2 = r2.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r2.NodeId);
                                                var childSkillId = UaHelpers.ToNodeId(expanded2, session);
                                                if (childSkillId == null) continue;
                                                var childName = r2.DisplayName?.Text ?? r2.BrowseName?.Name ?? childSkillId.ToString();
                                                // skip type-definition nodes like SkillSetType which are not actual skills
                                                if (string.Equals(childName, "SkillSetType", StringComparison.OrdinalIgnoreCase))
                                                {
                                                    UAClient.Common.Log.Debug($"RemoteModule '{Name}': skipping type node {childName}");
                                                    continue;
                                                }
                                                // Use factory to create skill (module-level skills)
                                                var skillObj = await CreateRemoteObjectFromTypeDefinitionAsync(session, childSkillId, childName);
                                                if (skillObj is RemoteSkill rs)
                                                {
                                                    lock (dictLock)
                                                    {
                                                        SkillSet[childName] = rs;
                                                        // keep compatibility: also register in Methods
                                                        Methods[childName] = new RemoteMethod(childName, childSkillId, _client);
                                                        Methods[$"skill:{childName}"] = rs;
                                                    }
                                                    UAClient.Common.Log.Info($"RemoteModule '{Name}': added Skill '{childName}' to SkillSet and Methods");
                                                }
                                                else
                                                {
                                                    UAClient.Common.Log.Warn($"RemoteModule '{Name}': failed to create skill for {childName}");
                                                }
                                            }
                                            catch { }
                                        }
                                     }
                                 }
                                 catch { }
                                 return;
                             }

                            // Heuristics based on browse name and display name
                            if (browseName.IndexOf("Skill", StringComparison.OrdinalIgnoreCase) >= 0 || name.IndexOf("Skill", StringComparison.OrdinalIgnoreCase) >= 0)
                            {
                                UAClient.Common.Log.Info($"RemoteModule '{Name}': creating RemoteSkill for {name}");
                                lock (dictLock)
                                {
                                    Methods[name] = new RemoteMethod(name, childId, _client); // compatibility
                                    Methods[$"skill:{name}"] = new RemoteSkill(name, childId, _client, _remoteServer);
                                }
                            }
                            else
                            {
                                // Try to create object based on TypeDefinition
                                var remoteObj = await CreateRemoteObjectFromTypeDefinitionAsync(session, childId, name);
                                if (remoteObj != null)
                                {
                                    lock (dictLock)
                                    {
                                        if (remoteObj is RemoteLock lockObj)
                                        {
                                            // set single Lock instance
                                            Lock = lockObj;
                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': set Lock '{name}'");
                                        }
                                        else if (remoteObj is RemotePort port)
                                        {
                                            Ports[name] = port;
                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': added Port '{name}'");
                                        }
                                        else if (remoteObj is RemoteStorage storage)
                                        {
                                            Storages[name] = storage;
                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': added Storage '{name}'");
                                        }
                                        else if (remoteObj is RemoteComponent component)
                                        {
                                            Components[name] = component;
                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': added Component '{name}'");
                                        }
                                        else if (remoteObj is RemoteSkill skill)
                                        {
                                            Methods[name] = new RemoteMethod(name, childId, _client);
                                            Methods[$"skill:{name}"] = skill;
                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': added Skill '{name}'");
                                        }
                                    }
                                }
                                else
                                {
                                    // generic method/object — only create a RemoteMethod entry if node is actually a Method
                                    if (r.NodeClass == NodeClass.Method)
                                    {
                                        lock (dictLock) { Methods[name] = new RemoteMethod(name, childId, _client); }
                                    }
                                }
                            }
                        }
                        catch { }
                    }));
                }

                // await processing of this batch of children
                try { await System.Threading.Tasks.Task.WhenAll(tasks); } catch { }
            }
        }

        public async System.Threading.Tasks.Task SetupSubscriptionsAsync(SubscriptionManager? subscriptionManager = null, bool createSubscriptions = true)
        {
            // ensure methods discovered
            await DiscoverMethodsAsync();

            // create a SubscriptionManager if caller didn't provide one
            if (subscriptionManager == null)
            {
                try { subscriptionManager = new SubscriptionManager(_client); }
                catch { /* if creation fails, continue without subscriptions */ }
            }

            // ensure Components are set up
            foreach (var c in Components.Values)
            {
                try { await c.SetupSubscriptionsAsync(subscriptionManager, createSubscriptions); } catch { }
            }

            foreach (var m in Methods.Values)
            {
                try { await m.SetupSubscriptionsAsync(subscriptionManager, true); } catch { }
            }
            // Also subscribe to module variables (Locks, Ports, Storages) similar to pyuaadapter
            try
            {
                // Locks: prefer single Lock; always set client references so reads/writes work
                if (Lock != null)
                {
                    foreach (var lv in Lock.Variables.Values) lv.SetClient(_client);
                    // Only create subscriptions if explicitly requested
                    if (createSubscriptions && subscriptionManager != null)
                    {
                        foreach (var kv in Lock.Variables.Values)
                        {
                            try { await kv.SetupSubscriptionAsync(subscriptionManager); } catch { }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"SetupSubscriptionsAsync: failed to subscribe variables: {ex.Message}");
            }

            // Subscribe to Monitoring variables (only when requested). Always set client reference.
            try
            {
                foreach (var kv in _monitoring_nodes)
                {
                    try
                    {
                        kv.Value.SetClient(_client);
                        if (createSubscriptions && subscriptionManager != null)
                        {
                            try { await kv.Value.SetupSubscriptionAsync(subscriptionManager); } catch { }
                        }
                    }
                    catch { }
                }
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"SetupSubscriptionsAsync: failed to subscribe monitoring variables: {ex.Message}");
            }
        }

        // Subscribe only core variables for the module: Monitoring variables and Lock variables, and propagate to skills/components
        public async Task SubscribeCoreAsync(SubscriptionManager subscriptionManager)
        {
            if (subscriptionManager == null) return;
            var session = _client.Session ?? throw new InvalidOperationException("No session");
            try
            {
                // Ensure monitoring variables have client and subscribe
                foreach (var kv in _monitoring_nodes)
                {
                    try
                    {
                        kv.Value.SetClient(_client);
                        await kv.Value.SetupSubscriptionAsync(subscriptionManager);
                    }
                    catch { }
                }

                // Lock variables
                if (Lock != null)
                {
                    foreach (var lv in Lock.Variables.Values)
                    {
                        try { lv.SetClient(_client); await lv.SetupSubscriptionAsync(subscriptionManager); } catch { }
                    }
                }

                // Subscribe core for skills and components contained in this module
                foreach (var m in Methods.Values.OfType<RemoteSkill>())
                {
                    try { await m.SubscribeCoreAsync(subscriptionManager); } catch { }
                }
                foreach (var c in Components.Values)
                {
                    try { await c.SubscribeCoreAsync(subscriptionManager); } catch { }
                }
            }
            catch { }
        }

        /// <summary>
        /// Ensure the module's first port is coupled. This checks the couple skill state and starts it if needed.
        /// </summary>
        public async System.Threading.Tasks.Task CoupleAsync(TimeSpan? timeout = null)
        {
            timeout ??= TimeSpan.FromSeconds(30);
            try
            {
                if (Ports.Count == 0) return;
                var firstPort = Ports.Values.First();
                var isCoupled = await firstPort.IsCoupledAsync(_client);
                if (isCoupled)
                {
                    UAClient.Common.Log.Info($"Module '{Name}': first port '{firstPort.Name}' already coupled");
                    return;
                }
                UAClient.Common.Log.Info($"Module '{Name}': coupling first port '{firstPort.Name}'");
                await firstPort.CoupleAsync(_client, timeout);
                UAClient.Common.Log.Info($"Module '{Name}': coupling attempt finished for port '{firstPort.Name}'");
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"Module '{Name}': CoupleAsync failed: {ex.Message}");
            }
        }

        public async System.Threading.Tasks.Task<bool?> LockAsync(Session session)
        {
            if (session == null) return null;

            // Prefer an already discovered Lock instance
            RemoteLock? lockObj = Lock;

            // If not present, try to discover a candidate under the module node
            if (lockObj == null)
            {
                try
                {
                    var browser = new Browser(session)
                    {
                        BrowseDirection = BrowseDirection.Forward,
                        ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                        NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                    };
                    var refs = await browser.BrowseAsync(BaseNodeId);
                    if (refs != null)
                    {
                        foreach (var r in refs)
                        {
                            try
                            {
                                if (r?.NodeId == null) continue;
                                var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                                var candidateId = UaHelpers.ToNodeId(expanded, session);
                                if (candidateId == null) continue;
                                var candidateName = r.DisplayName?.Text ?? r.BrowseName?.Name ?? string.Empty;
                                // If name suggests Lock or type matches LockingServicesType, choose it
                                if (candidateName.IndexOf("Lock", StringComparison.OrdinalIgnoreCase) >= 0 ||
                                    await IsTypeOrSubtypeOfAsync(session, candidateId, new System.Collections.Generic.HashSet<string> { "LockingServicesType" }))
                                {
                                    lockObj = new RemoteLock(candidateName, candidateId);
                                    await RemoteVariableCollector.AddVariableNodesAsync(session, candidateId, lockObj.NodeMap, lockObj.Variables, true);
                                    Lock = lockObj;
                                    UAClient.Common.Log.Info($"RemoteModule '{Name}': discovered Lock candidate '{candidateName}' via fallback");
                                    break;
                                }
                            }
                            catch { }
                        }
                    }
                }
                catch { }
            }

            if (lockObj == null) return null;

            UAClient.Common.Log.Info($"Locking module {Name} via lock {lockObj.Name}");
            try
            {
                UAClient.Common.Log.Debug($"RemoteModule '{Name}': invoking lock Init on {lockObj.Name} (node={lockObj.BaseNodeId})");
                var initOk = await lockObj.InitLockAsync(session);
                if (!initOk)
                {
                    UAClient.Common.Log.Warn($"RemoteModule '{Name}': InitLock call did not succeed (or no lock method found)");
                }
                var waitTimeout = TimeSpan.FromSeconds(10);
                var lockedNow = await lockObj.WaitForLockedAsync(session, waitTimeout);
                var lockedText = lockedNow ? "true" : "false/timeout";
                UAClient.Common.Log.Info($"Module locked state={lockedText}");
                if (!lockedNow)
                {
                    UAClient.Common.Log.Warn($"Module lock not confirmed for {Name} after {waitTimeout.TotalSeconds}s");
                }
                return lockedNow;
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"Lock init failed: {ex.Message}");
                return null;
            }
        }

        public async System.Threading.Tasks.Task<bool?> UnlockAsync(Session session)
        {
            if (session == null) return null;

            var lockObj = Lock;
            if (lockObj == null) return null;
            UAClient.Common.Log.Info($"Unlocking module {Name} via lock {lockObj.Name}");
            try
            {
                await lockObj.ReleaseLockAsync(session);
                var locked = await lockObj.IsLockedAsync(session);
                var lockedText = locked.HasValue ? (locked.Value ? "true" : "false") : "unknown";
                UAClient.Common.Log.Info($"Module locked state after unlock={lockedText}");
                return locked;
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"Unlock failed: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Start the module's startup skill. Optionally perform coupling first (default=true).
        /// </summary>
        public async System.Threading.Tasks.Task StartAsync(bool reset = true, TimeSpan? timeout = null, bool couple = true)
        {
            timeout ??= TimeSpan.FromSeconds(10);
            // perform coupling first if requested
            if (couple)
            {
                await CoupleAsync(timeout);
            }
            
            var session = _client?.Session ?? throw new InvalidOperationException("No session");

            var startupSkill = Methods.Values
                .OfType<RemoteSkill>()
                .FirstOrDefault(s => s.Name.IndexOf("Startup", StringComparison.OrdinalIgnoreCase) >= 0);
            if (startupSkill == null)
            {
                UAClient.Common.Log.Info($"No startup skill found in module {Name}");
                return;
            }

            // use global subscription manager from RemoteServer (injected during construction or available via _remoteServer property)
            var subMgr = _remoteServer?.SubscriptionManager;
            if (subMgr != null)
            {
                try { await startupSkill.SetupSubscriptionsAsync(subMgr, true); } catch { }
            }

            // get current state and do reset logging
            var st = await startupSkill.GetStateAsync();
            if (reset && (st == (int)UAClient.Common.SkillStates.Halted || st == (int)UAClient.Common.SkillStates.Completed))
            {
                UAClient.Common.Log.Info($"Resetting startup skill {startupSkill.Name} before start (state={st})");
            }

            if (st == null || st != (int)UAClient.Common.SkillStates.Running)
            {
                if (startupSkill.IsFinite)
                {
                    await startupSkill.ExecuteAsync(null, waitForCompletion: true, resetAfterCompletion: true, resetBeforeIfHalted: reset, timeout: TimeSpan.FromSeconds(60));
                    UAClient.Common.Log.Info($"Startup finite skill executed");
                }
                else
                {
                    await startupSkill.ExecuteAsync(null, waitForCompletion: false, resetBeforeIfHalted: reset, timeout: TimeSpan.FromSeconds(30));
                    var ok = await startupSkill.WaitForStateAsync(UAClient.Common.SkillStates.Running, TimeSpan.FromSeconds(30));
                    UAClient.Common.Log.Info($"Startup skill reached Running={ok}");
                }
            }
            else
            {
                UAClient.Common.Log.Warn($"Startup skill already running");
            }
        }

        private async System.Threading.Tasks.Task<bool> IsTypeOrSubtypeOfAsync(Session session, NodeId nodeId, System.Collections.Generic.IReadOnlySet<string> baseTypeNames)
        {
            var currentType = await GetTypeDefinitionAsync(session, nodeId);
            while (currentType != null)
            {
                var browseName = await GetBrowseNameAsync(session, currentType);
                if (browseName != null && baseTypeNames.Contains(browseName))
                {
                    return true;
                }
                // Get the supertype
                try
                {
                    var browser = new Browser(session)
                    {
                        BrowseDirection = BrowseDirection.Inverse,
                        ReferenceTypeId = ReferenceTypeIds.HasSubtype,
                        IncludeSubtypes = false,
                        NodeClassMask = (int)NodeClass.ObjectType
                    };
                    var refs = await browser.BrowseAsync(currentType);
                    if (refs != null && refs.Count > 0)
                    {
                        var expanded = refs[0].NodeId as ExpandedNodeId ?? new ExpandedNodeId(refs[0].NodeId);
                        currentType = UaHelpers.ToNodeId(expanded, session);
                    }
                    else
                    {
                        currentType = null;
                    }
                }
                catch
                {
                    currentType = null;
                }
            }
            return false;
        }
    }
}
