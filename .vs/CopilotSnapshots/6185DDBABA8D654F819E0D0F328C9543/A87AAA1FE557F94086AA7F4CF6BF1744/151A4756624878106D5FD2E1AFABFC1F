using System;
using System.Collections.Generic;
using Opc.Ua;
using Opc.Ua.Client;
using System.Linq;

namespace UAClient.Client
{
    public class RemoteModule
    {
        // If true, allow falling back to the first discovered Lock object when no
        // explicit Lock candidate was found. Default is false (strict mode).
        public bool AllowLockFallback { get; set; } = false;

        public string Name { get; }
        public NodeId BaseNodeId { get; }
        public IDictionary<string, BaseRemoteCallable> Methods { get; } = new Dictionary<string, BaseRemoteCallable>();
        public IDictionary<string, RemoteLock> Locks { get; } = new Dictionary<string, RemoteLock>();
        public IDictionary<string, RemotePort> Ports { get; } = new Dictionary<string, RemotePort>();
        public IDictionary<string, RemoteStorage> Storages { get; } = new Dictionary<string, RemoteStorage>();
        public IDictionary<string, RemoteComponent> Components { get; } = new Dictionary<string, RemoteComponent>(StringComparer.OrdinalIgnoreCase);
        private UaClient _client;
        private RemoteServer _remoteServer;

        public RemoteModule(string name, NodeId baseNodeId, UaClient client, RemoteServer remoteServer)
        {
            Name = name;
            BaseNodeId = baseNodeId;
            _client = client;
            _remoteServer = remoteServer;
        }

        private async System.Threading.Tasks.Task<NodeId?> GetTypeDefinitionAsync(Session session, NodeId nodeId)
        {
            try
            {
                var browser = new Browser(session)
                {
                    BrowseDirection = BrowseDirection.Forward,
                    ReferenceTypeId = ReferenceTypeIds.HasTypeDefinition,
                    IncludeSubtypes = true,
                    NodeClassMask = 0 // any
                };
                var refs = await browser.BrowseAsync(nodeId);
                if (refs != null && refs.Count > 0)
                {
                    var expanded = refs[0].NodeId as ExpandedNodeId ?? new ExpandedNodeId(refs[0].NodeId);
                    return UaHelpers.ToNodeId(expanded, session);
                }
            }
            catch { }
            return null;
        }

        private async System.Threading.Tasks.Task<object?> CreateRemoteObjectFromTypeDefinitionAsync(Session session, NodeId nodeId, string name)
        {
            var typeDef = await GetTypeDefinitionAsync(session, nodeId);
            if (typeDef == null) return null;

            // LockingServiceType: i=6388
            if (typeDef == new NodeId(6388))
            {
                var lockObj = new RemoteLock(name, nodeId);
                await RemoteVariableCollector.AddVariableNodesAsync(session, nodeId, lockObj.NodeMap, lockObj.Variables, true);
                // Populate descriptor and methods
                var desc = new RemoteLockDescriptor { BaseNodeId = nodeId };
                // Enumerate children for methods
                try
                {
                    var browserLock = new Browser(session)
                    {
                        BrowseDirection = BrowseDirection.Forward,
                        ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                        NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                    };
                    var refsLock = await browserLock.BrowseAsync(nodeId);
                    if (refsLock != null)
                    {
                        foreach (var rLock in refsLock)
                        {
                            try
                            {
                                if (rLock?.NodeId == null) continue;
                                var expandedLock = rLock.NodeId as ExpandedNodeId ?? new ExpandedNodeId(rLock.NodeId);
                                var mId = UaHelpers.ToNodeId(expandedLock, session);
                                if (mId == null) continue;
                                var mName = rLock.DisplayName?.Text ?? rLock.BrowseName?.Name ?? mId.ToString();
                                var rm = new RemoteMethod(mName, mId, _client);
                                lockObj.Methods[mName] = rm;
                                lockObj.MethodsNodeMap[mId] = rm;
                                // Map to descriptor and properties
                                if (mName.IndexOf("InitLock", StringComparison.OrdinalIgnoreCase) >= 0) { desc.InitLock = mId; lockObj.InitLock = rm; }
                                if (mName.IndexOf("BreakLock", StringComparison.OrdinalIgnoreCase) >= 0) { desc.BreakLock = mId; lockObj.BreakLock = rm; }
                                if (mName.IndexOf("ExitLock", StringComparison.OrdinalIgnoreCase) >= 0) { desc.ExitLock = mId; lockObj.ExitLock = rm; }
                                if (mName.IndexOf("RenewLock", StringComparison.OrdinalIgnoreCase) >= 0) { desc.RenewLock = mId; lockObj.RenewLock = rm; }
                                if (mName.IndexOf("Skill", StringComparison.OrdinalIgnoreCase) >= 0)
                                {
                                    var rs = new RemoteSkill(mName, mId, _client, _remoteServer);
                                    lockObj.Methods[$"skill:{mName}"] = rs;
                                    lockObj.MethodsNodeMap[mId] = rs;
                                }
                            }
                            catch { }
                        }
                    }
                }
                catch { }
                // Map variables to descriptor
                foreach (var kv in lockObj.Variables)
                {
                    var key = kv.Key ?? "";
                    var nid = kv.Value.NodeId;
                    if (key.IndexOf("Locked", StringComparison.OrdinalIgnoreCase) >= 0) desc.Locked = nid;
                    if (key.IndexOf("LockingUser", StringComparison.OrdinalIgnoreCase) >= 0) desc.LockingUser = nid;
                    if (key.IndexOf("LockingClient", StringComparison.OrdinalIgnoreCase) >= 0) desc.LockingClient = nid;
                    if (key.IndexOf("RemainingLockTime", StringComparison.OrdinalIgnoreCase) >= 0) desc.RemainingLockTime = nid;
                    if (key.IndexOf("CurrentState", StringComparison.OrdinalIgnoreCase) >= 0 || key.IndexOf("State", StringComparison.OrdinalIgnoreCase) >= 0) desc.CurrentState = nid;
                }
                // Set convenience properties
                if (lockObj.Variables.TryGetValue("Locked", out var rvLocked)) lockObj.Locked = rvLocked;
                if (lockObj.Variables.TryGetValue("LockingUser", out var rvUser)) lockObj.LockingUser = rvUser;
                if (lockObj.Variables.TryGetValue("LockingClient", out var rvClient)) lockObj.LockingClient = rvClient;
                if (lockObj.Variables.TryGetValue("RemainingLockTime", out var rvRemaining)) lockObj.RemainingLockTime = rvRemaining;
                if (lockObj.Variables.TryGetValue("CurrentState", out var rvState)) lockObj.CurrentState = rvState;
                lockObj.Descriptor = desc;
                return lockObj;
            }
            // PortType: ns=5;i=1010
            else if (typeDef == new NodeId(1010, 5))
            {
                var port = new RemotePort(name, nodeId, this);
                await RemoteVariableCollector.AddVariableNodesAsync(session, nodeId, port.NodeMap, port.Variables, true);
                // Attach methods
                try
                {
                    var browser3 = new Browser(session)
                    {
                        BrowseDirection = BrowseDirection.Forward,
                        ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                        NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                    };
                    var refs3 = await browser3.BrowseAsync(nodeId);
                    if (refs3 != null)
                    {
                        foreach (var r3 in refs3)
                        {
                            try
                            {
                                if (r3?.NodeId == null) continue;
                                var expanded3 = r3.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r3.NodeId);
                                var methodId = UaHelpers.ToNodeId(expanded3, session);
                                if (methodId == null) continue;
                                var methodName = r3.DisplayName?.Text ?? r3.BrowseName?.Name ?? methodId.ToString();
                                var rm = new RemoteMethod(methodName, methodId, _client);
                                port.Methods[methodName] = rm;
                                port.MethodsNodeMap[methodId] = rm;
                                if (methodName.IndexOf("Skill", StringComparison.OrdinalIgnoreCase) >= 0)
                                {
                                    var rs = new RemoteSkill(methodName, methodId, _client, _remoteServer);
                                    port.Methods[$"skill:{methodName}"] = rs;
                                    port.MethodsNodeMap[methodId] = rs;
                                }
                            }
                            catch { }
                        }
                    }
                }
                catch { }
                return port;
            }
            // StorageType: ns=5;i=1018
            else if (typeDef == new NodeId(1018, 5))
            {
                var storage = new RemoteStorage(name, nodeId);
                await RemoteVariableCollector.AddVariableNodesAsync(session, nodeId, storage.NodeMap, storage.Variables, true);
                return storage;
            }
            // MachineryItemType and subtypes: ns=5;i=1007, 1008, 1009, 1017, 1020, 1019, 1021, 1025, 1022
            else if (typeDef.NamespaceIndex == 5 && (typeDef.IdentifierAsUInt32 == 1007 || typeDef.IdentifierAsUInt32 == 1008 || typeDef.IdentifierAsUInt32 == 1009 ||
                     typeDef.IdentifierAsUInt32 == 1017 || typeDef.IdentifierAsUInt32 == 1020 || typeDef.IdentifierAsUInt32 == 1019 ||
                     typeDef.IdentifierAsUInt32 == 1021 || typeDef.IdentifierAsUInt32 == 1025 || typeDef.IdentifierAsUInt32 == 1022))
            {
                var component = new RemoteComponent(name, nodeId, _client, _remoteServer);
                return component;
            }
            return null;
        }

        public async System.Threading.Tasks.Task DiscoverMethodsAsync()
        {
            var session = _client.Session;
            if (session == null) return;

            var visited = new System.Collections.Concurrent.ConcurrentDictionary<string, bool>(StringComparer.OrdinalIgnoreCase);
            var queue = new System.Collections.Concurrent.ConcurrentQueue<NodeId>();
            queue.Enqueue(BaseNodeId);
            var dictLock = new object();

            while (queue.TryDequeue(out var node))
            {
                if (node == null) continue;
                var nodeKey = node.ToString();
                if (!visited.TryAdd(nodeKey, true)) continue;

                var browser = new Browser(session)
                {
                    BrowseDirection = BrowseDirection.Forward,
                    ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                    NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                };
                ReferenceDescriptionCollection refs = null;
                try { refs = await browser.BrowseAsync(node); } catch { }
                if (refs == null) continue;

                var tasks = new System.Collections.Generic.List<System.Threading.Tasks.Task>();
                foreach (var r in refs)
                {
                    // process each child reference in parallel
                    tasks.Add(System.Threading.Tasks.Task.Run(async () =>
                    {
                        try
                        {
                            if (r?.NodeId == null) return;
                            var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                            var childId = UaHelpers.ToNodeId(expanded, session);
                            if (childId == null) return;
                            var name = r.DisplayName?.Text ?? childId.ToString() ?? "<unknown>";
                            var browseName = r.BrowseName?.Name ?? "";

                            UAClient.Common.Log.Debug($"RemoteModule '{Name}': discovered child {name} (browse='{browseName}') of class {r.NodeClass}");

                            // If this is a SkillSet container, enumerate children and create skills
                            if (string.Equals(browseName, "SkillSet", StringComparison.OrdinalIgnoreCase) || string.Equals(name, "SkillSet", StringComparison.OrdinalIgnoreCase))
                            {
                                try
                                {
                                    var browser2 = new Browser(session)
                                    {
                                        BrowseDirection = BrowseDirection.Forward,
                                        ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                                        NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
                                    };
                                    var refs2 = await browser2.BrowseAsync(childId);
                                    if (refs2 != null)
                                    {
                                        foreach (var r2 in refs2)
                                        {
                                            try
                                            {
                                                if (r2?.NodeId == null) continue;
                                                var expanded2 = r2.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r2.NodeId);
                                                var childSkillId = UaHelpers.ToNodeId(expanded2, session);
                                                if (childSkillId == null) continue;
                                                var childName = r2.DisplayName?.Text ?? r2.BrowseName?.Name ?? childSkillId.ToString();
                                                // skip type-definition nodes like SkillSetType which are not actual skills
                                                if (string.Equals(childName, "SkillSetType", StringComparison.OrdinalIgnoreCase))
                                                {
                                                    UAClient.Common.Log.Debug($"RemoteModule '{Name}': skipping type node {childName}");
                                                    continue;
                                                }
                                                UAClient.Common.Log.Info($"RemoteModule '{Name}': creating RemoteSkill for {childName}");
                                                lock (dictLock)
                                                {
                                                    Methods[childName] = new RemoteMethod(childName, childSkillId, _client);
                                                    Methods[$"skill:{childName}"] = new RemoteSkill(childName, childSkillId, _client, _remoteServer);
                                                }

                                                // also enqueue child for deeper discovery
                                                queue.Enqueue(childSkillId);
                                            }
                                            catch { }
                                        }
                                    }
                                }
                                catch { }
                                return;
                            }

                            // Heuristics based on browse name and display name
                            if (browseName.IndexOf("Skill", StringComparison.OrdinalIgnoreCase) >= 0 || name.IndexOf("Skill", StringComparison.OrdinalIgnoreCase) >= 0)
                            {
                                UAClient.Common.Log.Info($"RemoteModule '{Name}': creating RemoteSkill for {name}");
                                lock (dictLock)
                                {
                                    Methods[name] = new RemoteMethod(name, childId, _client); // compatibility
                                    Methods[$"skill:{name}"] = new RemoteSkill(name, childId, _client, _remoteServer);
                                }
                            }
                            else
                            {
                                // Try to create object based on TypeDefinition
                                var remoteObj = await CreateRemoteObjectFromTypeDefinitionAsync(session, childId, name);
                                if (remoteObj != null)
                                {
                                    lock (dictLock)
                                    {
                                        if (remoteObj is RemoteLock lockObj)
                                        {
                                            Locks[name] = lockObj;
                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': added Lock '{name}'");
                                        }
                                        else if (remoteObj is RemotePort port)
                                        {
                                            Ports[name] = port;
                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': added Port '{name}'");
                                        }
                                        else if (remoteObj is RemoteStorage storage)
                                        {
                                            Storages[name] = storage;
                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': added Storage '{name}'");
                                        }
                                        else if (remoteObj is RemoteComponent component)
                                        {
                                            Components[name] = component;
                                            UAClient.Common.Log.Info($"RemoteModule '{Name}': added Component '{name}'");
                                        }
                                    }
                                }
                                else
                                {
                                    // generic method/object — create a RemoteMethod entry to allow invocation
                                    lock (dictLock) { Methods[name] = new RemoteMethod(name, childId, _client); }
                                }
                            }

                            // enqueue objects and variables for deeper traversal
                            if (r.NodeClass == NodeClass.Object || r.NodeClass == NodeClass.Variable)
                            {
                                queue.Enqueue(childId);
                            }
                        }
                        catch { }
                    }));
                }

                // await processing of this batch of children
                try { await System.Threading.Tasks.Task.WhenAll(tasks); } catch { }
            }
        }

        public async System.Threading.Tasks.Task SetupSubscriptionsAsync(SubscriptionManager? subscriptionManager = null, bool createSubscriptions = true)
        {
            // ensure methods discovered
            await DiscoverMethodsAsync();

            // create a SubscriptionManager if caller didn't provide one
            if (subscriptionManager == null)
            {
                try { subscriptionManager = new SubscriptionManager(_client); }
                catch { /* if creation fails, continue without subscriptions */ }
            }

            // ensure Components are set up
            foreach (var c in Components.Values)
            {
                try { await c.SetupSubscriptionsAsync(subscriptionManager, createSubscriptions); } catch { }
            }

            foreach (var m in Methods.Values)
            {
                try { await m.SetupSubscriptionsAsync(subscriptionManager, true); } catch { }
            }
            // Also subscribe to module variables (Locks, Ports, Storages) similar to pyuaadapter
            try
            {
                // Locks
                foreach (var l in Locks.Values)
                {
                    // inject client into lock variables
                    foreach (var lv in l.Variables.Values) lv.SetClient(_client);
                    foreach (var kv in l.Variables.Values)
                    {
                        try { await kv.SetupSubscriptionAsync(subscriptionManager); } catch { }
                    }
                }

                // Ports
                foreach (var p in Ports.Values)
                {
                    foreach (var pv in p.Variables.Values) pv.SetClient(_client);
                    foreach (var kv in p.Variables.Values)
                    {
                        try { await kv.SetupSubscriptionAsync(subscriptionManager); } catch { }
                    }
                }

                // Storages
                foreach (var s in Storages.Values)
                {
                    foreach (var sv in s.Variables.Values) sv.SetClient(_client);
                    foreach (var kv in s.Variables.Values)
                    {
                        try { await kv.SetupSubscriptionAsync(subscriptionManager); } catch { }
                    }
                }
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"SetupSubscriptionsAsync: failed to subscribe variables: {ex.Message}");
            }
        }

        /// <summary>
        /// Ensure the module's first port is coupled. This checks the couple skill state and starts it if needed.
        /// </summary>
        public async System.Threading.Tasks.Task CoupleAsync(TimeSpan? timeout = null)
        {
            timeout ??= TimeSpan.FromSeconds(30);
            try
            {
                if (Ports.Count == 0) return;
                var firstPort = Ports.Values.First();
                var isCoupled = await firstPort.IsCoupledAsync(_client);
                if (isCoupled)
                {
                    UAClient.Common.Log.Info($"Module '{Name}': first port '{firstPort.Name}' already coupled");
                    return;
                }
                UAClient.Common.Log.Info($"Module '{Name}': coupling first port '{firstPort.Name}'");
                await firstPort.CoupleAsync(_client, timeout);
                UAClient.Common.Log.Info($"Module '{Name}': coupling attempt finished for port '{firstPort.Name}'");
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"Module '{Name}': CoupleAsync failed: {ex.Message}");
            }
        }

        public async System.Threading.Tasks.Task<bool?> LockAsync(Session session)
        {
            if (session == null) return null;
            if (Locks.Count == 0) return null;
            // Prefer a lock named exactly 'Lock' or the LockingServices object; otherwise try to find the lock object
            // that actually exposes an InitLock method.
            RemoteLock? lockObj = null;
            if (Locks.TryGetValue("Lock", out var namedLock))
            {
                lockObj = namedLock;
            }
            else
            {
                // find first candidate whose name contains 'Lock' (case-insensitive)
                lockObj = Locks.Values.FirstOrDefault(l => l.Name != null && l.Name.IndexOf("Lock", StringComparison.OrdinalIgnoreCase) >= 0);
            }
            // If still not chosen, try to find one that actually contains an InitLock method (without calling it)
            if (lockObj == null)
            {
                foreach (var cand in Locks.Values)
                {
                    try
                    {
                        if (await cand.HasMethodAsync(session, "InitLock", 3))
                        {
                            lockObj = cand;
                            break;
                        }
                    }
                    catch { }
                }
            }
            // If we couldn't find a suitable lock candidate above, decide what to do:
            if (lockObj == null)
            {
                if (Locks.Count == 1)
                {
                    // If there is exactly one Lock object, it's reasonable to use it.
                    lockObj = Locks.Values.First();
                    UAClient.Common.Log.Warn($"No explicit Lock candidate found; using the only discovered lock '{lockObj.Name}'");
                }
                else if (AllowLockFallback && Locks.Count > 0)
                {
                    // Backwards-compatible tolerant mode: fall back to first discovered lock.
                    lockObj = Locks.Values.First();
                    UAClient.Common.Log.Warn($"AllowLockFallback is enabled: falling back to first discovered lock '{lockObj.Name}'");
                }
                else
                {
                    UAClient.Common.Log.Warn($"No suitable lock found for module {Name}; aborting LockAsync (set AllowLockFallback=true to allow tolerant fallback)");
                    return null;
                }
            }
            UAClient.Common.Log.Info($"Locking module {Name} via lock {lockObj.Name}");
            try
            {
                // diagnostics: enumerate lock node children before calling
                UAClient.Common.Log.Debug($"RemoteModule '{Name}': invoking lock Init on {lockObj.Name} (node={lockObj.BaseNodeId})");
                var initOk = await lockObj.InitLockAsync(session);
                if (!initOk)
                {
                    UAClient.Common.Log.Warn($"RemoteModule '{Name}': InitLock call did not succeed (or no lock method found)");
                }
                // After attempting Init, poll the lock state until it's true or timeout
                var waitTimeout = TimeSpan.FromSeconds(10);
                var lockedNow = await lockObj.WaitForLockedAsync(session, waitTimeout);
                var lockedText = lockedNow ? "true" : "false/timeout";
                UAClient.Common.Log.Info($"Module locked state={lockedText}");
                if (!lockedNow)
                {
                    UAClient.Common.Log.Warn($"Module lock not confirmed for {Name} after {waitTimeout.TotalSeconds}s");
                }
                return lockedNow;
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"Lock init failed: {ex.Message}");
                return null;
            }
        }

        public async System.Threading.Tasks.Task<bool?> UnlockAsync(Session session)
        {
            if (session == null) return null;
            if (Locks.Count == 0) return null;
            var lockObj = Locks.Values.First();
            UAClient.Common.Log.Info($"Unlocking module {Name} via lock {lockObj.Name}");
            try
            {
                await lockObj.ReleaseLockAsync(session);
                var locked = await lockObj.IsLockedAsync(session);
                var lockedText = locked.HasValue ? (locked.Value ? "true" : "false") : "unknown";
                UAClient.Common.Log.Info($"Module locked state after unlock={lockedText}");
                return locked;
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"Unlock failed: {ex.Message}");
                return null;
            }
        }

        /// <summary>
        /// Start the module's startup skill. Optionally perform coupling first (default=true).
        /// </summary>
        public async System.Threading.Tasks.Task StartAsync(bool reset = true, TimeSpan? timeout = null, bool couple = true)
        {
            timeout ??= TimeSpan.FromSeconds(10);
            // perform coupling first if requested
            if (couple)
            {
                await CoupleAsync(timeout);
            }
            
            var session = _client?.Session ?? throw new InvalidOperationException("No session");

            var startupSkill = Methods.Values
                .OfType<RemoteSkill>()
                .FirstOrDefault(s => s.Name.IndexOf("Startup", StringComparison.OrdinalIgnoreCase) >= 0);
            if (startupSkill == null)
            {
                UAClient.Common.Log.Info($"No startup skill found in module {Name}");
                return;
            }

            // use global subscription manager from RemoteServer (injected during construction or available via _remoteServer property)
            var subMgr = _remoteServer?.SubscriptionManager;
            if (subMgr != null)
            {
                try { await startupSkill.SetupSubscriptionsAsync(subMgr, true); } catch { }
            }

            // get current state and do reset logging
            var st = await startupSkill.GetStateAsync();
            if (reset && (st == (int)UAClient.Common.SkillStates.Halted || st == (int)UAClient.Common.SkillStates.Completed))
            {
                UAClient.Common.Log.Info($"Resetting startup skill {startupSkill.Name} before start (state={st})");
            }

            if (st == null || st != (int)UAClient.Common.SkillStates.Running)
            {
                if (startupSkill.IsFinite)
                {
                    await startupSkill.ExecuteAsync(null, waitForCompletion: true, resetAfterCompletion: true, resetBeforeIfHalted: reset, timeout: TimeSpan.FromSeconds(60), subscriptionManager: subMgr);
                    UAClient.Common.Log.Info($"Startup finite skill executed");
                }
                else
                {
                    await startupSkill.ExecuteAsync(null, waitForCompletion: false, resetBeforeIfHalted: reset, timeout: TimeSpan.FromSeconds(30), subscriptionManager: subMgr);
                    var ok = await startupSkill.WaitForStateAsync(UAClient.Common.SkillStates.Running, TimeSpan.FromSeconds(30));
                    UAClient.Common.Log.Info($"Startup skill reached Running={ok}");
                }
            }
            else
            {
                UAClient.Common.Log.Warn($"Startup skill already running");
            }
        }
    }
}
