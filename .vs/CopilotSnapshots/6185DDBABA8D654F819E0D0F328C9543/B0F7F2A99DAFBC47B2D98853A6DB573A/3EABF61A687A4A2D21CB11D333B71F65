using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Opc.Ua;

namespace UAClient.Client
{
    public class RemotePort
    {
        public string Name { get; }
        public NodeId BaseNodeId { get; }
        public IDictionary<string, RemoteVariable> Variables { get; } = new Dictionary<string, RemoteVariable>(StringComparer.OrdinalIgnoreCase);
        public IDictionary<NodeId, RemoteVariable> NodeMap { get; } = new Dictionary<NodeId, RemoteVariable>();
        // Local methods/skills attached to this port (populated during discovery)
        public IDictionary<string, BaseRemoteCallable> Methods { get; } = new Dictionary<string, BaseRemoteCallable>(StringComparer.OrdinalIgnoreCase);
        public IDictionary<NodeId, BaseRemoteCallable> MethodsNodeMap { get; } = new Dictionary<NodeId, BaseRemoteCallable>();
        public RemoteModule? Module { get; }

        public RemotePort(string name, NodeId baseNodeId, RemoteModule? module = null)
        {
            Name = name;
            BaseNodeId = baseNodeId;
            Module = module;
        }

        // Expose current state as a property (read from Variables["CurrentState"] or similar)
        public object? CurrentState
        {
            get
            {
                if (Variables.TryGetValue("CurrentState", out var stateVar))
                {
                    return stateVar.Value;
                }
                if (Variables.TryGetValue("State", out var altStateVar))
                {
                    return altStateVar.Value;
                }
                return null;
            }
        }

        // Convenience properties (mirrors Python RemotePort)
        public bool ActivePort
        {
            get
            {
                if (Variables.TryGetValue("IsActive", out var rv) && rv?.Value is bool b)
                {
                    return b;
                }
                return false;
            }
        }

        public string? OwnRfidTag
        {
            get
            {
                if (Variables.TryGetValue("OwnRfidTag", out var rv) && rv?.Value != null) return rv.Value.ToString();
                return null;
            }
        }

        public string? PartnerRfidTag
        {
            get
            {
                if (Variables.TryGetValue("PartnerRfidTag", out var rv) && rv?.Value != null) return rv.Value.ToString();
                return null;
            }
        }

        public bool Closed
        {
            get
            {
                if (Variables.TryGetValue("MagnetsClosed", out var rv) && rv?.Value is bool b)
                {
                    return b;
                }
                return false;
            }
        }

        // Position property commented out as placeholder
        // public double[]? Position => Variables.TryGetValue("Position", out var p) ? p.Value as double[] : null;

        public string Type => "Port";

        public async Task<bool> IsCoupledAsync(UaClient client)
        {
            // Prefer couple skill state when available
            try
            {
                // check local methods first
                foreach (var kv in Methods)
                {
                    if (kv.Value is RemoteSkill rs && string.Equals(rs.Name, "CoupleSkill", StringComparison.OrdinalIgnoreCase))
                    {
                        var st = await rs.GetStateAsync();
                        if (st != null && st == (int)UAClient.Common.SkillStates.Running) return true;
                        return false;
                    }
                }
                // fallback to module-wide methods
                if (Module != null)
                {
                    foreach (var kv in Module.Methods)
                    {
                        if (kv.Value is RemoteSkill rs && string.Equals(rs.Name, "CoupleSkill", StringComparison.OrdinalIgnoreCase))
                        {
                            var st = await rs.GetStateAsync();
                            if (st != null && st == (int)UAClient.Common.SkillStates.Running) return true;
                            return false;
                        }
                    }
                }
            }
            catch { }
            return false;
        }

        public async Task CoupleAsync(UaClient client, TimeSpan? timeout = null)
        {
            timeout ??= TimeSpan.FromSeconds(30);
            if (Module == null) return;

            // find couple skill on this component (prefer local Methods)
            RemoteSkill? couple = null;
            foreach (var kv in Methods)
            {
                if (kv.Value is RemoteSkill rs && string.Equals(rs.Name, "CoupleSkill", StringComparison.OrdinalIgnoreCase))
                {
                    couple = rs;
                    break;
                }
            }
            if (couple == null && Module != null)
            {
                foreach (var kv in Module.Methods)
                {
                    if (kv.Value is RemoteSkill rs && string.Equals(rs.Name, "CoupleSkill", StringComparison.OrdinalIgnoreCase))
                    {
                        couple = rs;
                        break;
                    }
                }
            }
            if (couple == null)
            {
                // passive port, nothing to do
                return;
            }

            try
            {
                var st = await couple.GetStateAsync();
                // If the couple skill is already running, warn and return
                if (st == (int)UAClient.Common.SkillStates.Running)
                {
                    UAClient.Common.Log.Warn($"RemotePort '{Name}': CoupleSkill already running, skipping coupling");
                    return;
                }

                if (st == (int)UAClient.Common.SkillStates.Halted)
                {
                    try
                    {
                        // call Reset on the couple skill (will use its Execute/Reset logic)
                        // prefer cached reset method if available
                        var resetMethod = couple.ResetMethodNode ?? await couple.FindMethodNodeRecursive(client.Session, couple.BaseNodeId, "Reset");
                        if (resetMethod != null)
                        {
                            // prefer calling Reset on the state machine node if available
                            var obj = couple.StateMachineNode ?? couple.BaseNodeId;
                            await client.Session.CallAsync(obj, resetMethod, System.Threading.CancellationToken.None);
                            await couple.WaitForStateAsync(UAClient.Common.SkillStates.Ready, timeout.Value);
                        }
                    }
                    catch { }
                }
            }
            catch { }

            // if not coupled, start the couple skill. If Start fails with BadInvalidState, try Reset then Start again.
            try
            {
                var coupled = await IsCoupledAsync(client);
                if (!coupled)
                {
                    try
                    {
                        await couple.StartAsync();
                        await couple.WaitForStateAsync(UAClient.Common.SkillStates.Running, timeout.Value);
                    }
                    catch (Opc.Ua.ServiceResultException sre) when (sre.StatusCode == StatusCodes.BadInvalidState)
                    {
                        UAClient.Common.Log.Info($"RemotePort '{Name}': Couple start failed with BadInvalidState, attempting Reset then retry");
                        try
                        {
                            var resetTarget = couple.StateMachineNode ?? couple.BaseNodeId;
                            var resetMethod = await couple.FindMethodNodeRecursive(client.Session, resetTarget, "Reset")
                                              ?? await couple.FindMethodNodeRecursive(client.Session, couple.BaseNodeId, "Reset");
                            if (resetMethod != null)
                            {
                                await client.Session.CallAsync(resetTarget, resetMethod, System.Threading.CancellationToken.None);
                                await couple.WaitForStateAsync(UAClient.Common.SkillStates.Ready, TimeSpan.FromSeconds(10));
                                // retry start
                                await couple.StartAsync();
                                await couple.WaitForStateAsync(UAClient.Common.SkillStates.Running, timeout.Value);
                            }
                            else
                            {
                                UAClient.Common.Log.Warn($"RemotePort '{Name}': Reset method not found for CoupleSkill, cannot recover from BadInvalidState");
                            }
                        }
                        catch (Exception ex)
                        {
                            UAClient.Common.Log.Warn($"RemotePort '{Name}': Reset+retry failed: {ex.Message}");
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"RemotePort '{Name}': couple failed: {ex.Message}");
            }
        }

        public async Task UncoupleAsync(UaClient client, TimeSpan? timeout = null)
        {
            timeout ??= TimeSpan.FromSeconds(30);
            if (Module == null) return;

            RemoteSkill? couple = null;
            foreach (var kv in Module.Methods)
            {
                if (kv.Value is RemoteSkill rs && string.Equals(rs.Name, "CoupleSkill", StringComparison.OrdinalIgnoreCase))
                {
                    couple = rs;
                    break;
                }
            }
            if (couple == null) return;

            try
            {
                await couple.StopAsync();
                await couple.WaitForStateAsync(UAClient.Common.SkillStates.Halted, timeout.Value);
                var resetMethod = await couple.FindMethodNodeRecursive(client.Session, couple.BaseNodeId, "Reset");
                if (resetMethod != null)
                {
                    var obj = couple.StateMachineNode ?? couple.BaseNodeId;
                    await client.Session.CallAsync(obj, resetMethod, System.Threading.CancellationToken.None);
                    await couple.WaitForStateAsync(UAClient.Common.SkillStates.Ready, timeout.Value);
                }
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"RemotePort '{Name}': uncouple failed: {ex.Message}");
            }
        }

        // Ensure subscriptions for port variables and attached methods/skills
        public async Task SetupSubscriptionsAsync(SubscriptionManager? subscriptionManager)
        {
            // always create a SubscriptionManager when none provided
            if (subscriptionManager == null)
            {
                try { subscriptionManager = new SubscriptionManager(RemoteModuleHelper.GetUaClientFromModule(Module)); }
                catch { subscriptionManager = null; }
            }

            // subscribe attached methods/skills
            foreach (var m in Methods.Values)
            {
                try { await m.SetupSubscriptionsAsync(subscriptionManager, true); } catch { }
            }

            // subscribe port variables
            if (subscriptionManager != null)
            {
                foreach (var rv in Variables.Values)
                {
                    try { await rv.SetupSubscriptionAsync(subscriptionManager); } catch { }
                }
            }
        }
    }

    internal static class RemoteModuleHelper
    {
        public static UaClient? GetUaClientFromModule(RemoteModule? module)
        {
            return module == null ? null : (module.GetType().GetField("_client", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.GetValue(module) as UaClient);
        }
    }
}
