using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Threading.Tasks;
using Opc.Ua;
using Opc.Ua.Client;

namespace UAClient.Client
{
    public class RemoteSkill : BaseRemoteCallable
    {
        private readonly RemoteServer _remoteServer;
        private List<string>? _availableStates;
        private NodeId? _stateMachineNode;
        private NodeId? _currentStateNode;
        private NodeId? _startMethodNode;
        private NodeId? _resetMethodNode;
        private NodeId? _stopMethodNode;
        private NodeId? _abortMethodNode;
        private bool? _isFiniteHint = null;

        // cached state + subscribers (mirror Python behaviour)
        private Common.SkillStates _cachedState = Common.SkillStates.Halted;
        private List<Action<Common.SkillStates>> _stateSubscribers = new List<Action<Common.SkillStates>>();
        private readonly object _coreSubLock = new object();
        private bool _coreSubscribed = false;

        public NodeId? StateMachineNode => _stateMachineNode;
        public NodeId? CurrentStateNode => _currentStateNode;
        public NodeId? StartMethodNode => _startMethodNode;
        public NodeId? ResetMethodNode => _resetMethodNode;
        public NodeId? StopMethodNode => _stopMethodNode;
        public NodeId? AbortMethodNode => _abortMethodNode;

        // Expose a RemoteVariable for the current state if available via Monitoring map
        public RemoteVariable? CurrentStateVariable
        {
            get
            {
                if (Monitoring.TryGetValue("CurrentState", out var rv)) return rv;
                return null;
            }
        }

        // Expose current state as a property that returns the cached state value (sync access)
        public Common.SkillStates CurrentState => _cachedState;

        public RemoteSkill(string name, NodeId baseNodeId, UaClient client, RemoteServer remoteServer, bool? isFiniteHint = null) : base(name, baseNodeId, client)
        {
            _remoteServer = remoteServer;
            _isFiniteHint = isFiniteHint;
        }

        public async Task<NodeId?> FindMethodNodeRecursive(Session session, NodeId startNode, string methodName)
        {
            // Try fast path: translate common paths to NodeId via server-side TranslateBrowsePaths
            try
            {
                var try1 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { methodName });
                if (try1 != null) return try1;
                var try2 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "StateMachine", methodName });
                if (try2 != null) return try2;
                var try3 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "SkillExecution", "StateMachine", methodName });
                if (try3 != null) return try3;
            }
            catch { }

            var browser = new Browser(session)
            {
                BrowseDirection = BrowseDirection.Forward,
                // restrict browsing to HasComponent relationships to avoid wide hierarchical walks
                ReferenceTypeId = ReferenceTypeIds.HasComponent,
                NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
            };
            var queue = new Queue<NodeId>();
            var visited = new HashSet<string>(); // use string form to compare NodeIds safely
            queue.Enqueue(startNode);
            visited.Add(startNode.ToString());
            int inspected = 0;
            const int MaxInspected = 1000; // defensive cutoff to avoid pathological long searches

            while (queue.Count > 0)
            {
                var node = queue.Dequeue();
                if (++inspected > MaxInspected) break;
                ReferenceDescriptionCollection refs = null;
                try
                {
                    refs = await browser.BrowseAsync(node);
                }
                catch { }

                if (refs == null) continue;

                foreach (var r in refs)
                {
                    try
                    {
                        if (r?.NodeId == null) continue;
                        // Check for method-like nodes
                        if (r.NodeClass == NodeClass.Method)
                        {
                            var name = r.DisplayName?.Text ?? r.BrowseName?.Name;
                            if (!string.IsNullOrEmpty(name) && string.Equals(name, methodName, StringComparison.OrdinalIgnoreCase))
                            {
                                var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                                return UaHelpers.ToNodeId(expanded, session);
                            }
                        }

                        // enqueue objects/variables to look deeper
                        if (r.NodeClass == NodeClass.Object || r.NodeClass == NodeClass.Variable)
                        {
                            var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                            var childId = UaHelpers.ToNodeId(expanded, session);
                            if (childId != null)
                            {
                                var key = childId.ToString();
                                if (!visited.Contains(key))
                                {
                                    visited.Add(key);
                                    queue.Enqueue(childId);
                                }
                            }
                        }
                    }
                    catch { }
                }
            }

            return null;
        }

        public async Task WriteParameterAsync(string parameterName, object value)
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            // prefer ParameterSet map first if available
            if (ParameterSet.TryGetValue(parameterName, out var rv) && rv?.NodeId != null)
            {
                try
                {
                    await RemoteServerClient.WriteNodeAsync(rv.NodeId.ToString(), value);
                    return;
                }
                catch (ServiceResultException sre) when (sre.StatusCode == StatusCodes.BadOutOfRange)
                {
                    UAClient.Common.Log.Warn($"RemoteSkill '{Name}': failed to write parameter {parameterName}: BadOutOfRange (via ParameterSet)");
                    throw;
                }
                catch (Exception ex)
                {
                    UAClient.Common.Log.Warn($"RemoteSkill '{Name}': failed to write parameter {parameterName}: {ex.Message}");
                    throw;
                }
            }

            // fallback: attempt to locate parameter node dynamically
            NodeId? paramRoot = await FindNodeByBrowseNameRecursive(session, BaseNodeId, "ParameterSet");
            var varNode = paramRoot != null ? await FindVariableNodeRecursive(session, paramRoot, parameterName)
                                           : await FindVariableNodeRecursive(session, BaseNodeId, parameterName);
            if (varNode == null)
            {
                UAClient.Common.Log.Warn($"RemoteSkill '{Name}': parameter '{parameterName}' not found under {BaseNodeId}");
                return;
            }
            UAClient.Common.Log.Info($"RemoteSkill '{Name}': writing parameter {parameterName} -> {value}");
            // Use UaClient helper if available
            try
            {
                await RemoteServerClient.WriteNodeAsync(varNode.ToString(), value);
            }
            catch (ServiceResultException sre) when (sre.StatusCode == StatusCodes.BadOutOfRange)
            {
                // Attempt to read EURange or other metadata to help diagnosis
                try
                {
                    var eurangeNode = await FindNodeByBrowseNameRecursive(session, varNode, "EURange");
                    object? eurangeVal = null;
                    if (eurangeNode != null)
                    {
                        var dv = await session.ReadValueAsync(eurangeNode, System.Threading.CancellationToken.None);
                        eurangeVal = dv.Value;
                    }
                    UAClient.Common.Log.Warn($"RemoteSkill '{Name}': failed to write parameter {parameterName}: BadOutOfRange; attempted value={value}; EURange={eurangeVal}");
                }
                catch (Exception ex)
                {
                    UAClient.Common.Log.Warn($"RemoteSkill '{Name}': failed to write parameter {parameterName}: BadOutOfRange (and reading EURange failed): {ex.Message}");
                }
                throw;
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"RemoteSkill '{Name}': failed to write parameter {parameterName}: {ex.Message}");
            }
        }

        private async Task<NodeId?> FindVariableNodeRecursive(Session session, NodeId startNode, string variableName)
        {
            // Try translate-based fast paths
            try
            {
                var t1 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { variableName }); if (t1 != null) return t1;
                var t2 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "ParameterSet", variableName }); if (t2 != null) return t2;
                var t3 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "Monitoring", variableName }); if (t3 != null) return t3;
                var t4 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "SkillExecution", "StateMachine", variableName }); if (t4 != null) return t4;
            }
            catch { }

            var browser = new Browser(session)
            {
                BrowseDirection = BrowseDirection.Forward,
                ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                // include Objects as well so we can traverse through Object nodes to find nested Variables
                NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable)
            };
            var queue = new Queue<NodeId>(); queue.Enqueue(startNode);
            while (queue.Count > 0)
            {
                var node = queue.Dequeue();
                ReferenceDescriptionCollection refs = null;
                try { refs = await browser.BrowseAsync(node); } catch { }
                if (refs == null) continue;
                foreach (var r in refs)
                {
                    try
                    {
                        if (r?.NodeId == null) continue;
                        if (r.NodeClass == NodeClass.Variable)
                        {
                            var name = r.DisplayName?.Text ?? r.BrowseName?.Name;
                            if (!string.IsNullOrEmpty(name) && string.Equals(name, variableName, StringComparison.OrdinalIgnoreCase))
                            {
                                var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                                return UaHelpers.ToNodeId(expanded, session);
                            }
                        }
                        if (r.NodeClass == NodeClass.Object || r.NodeClass == NodeClass.Variable)
                        {
                            var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                            var childId = UaHelpers.ToNodeId(expanded, session);
                            if (childId != null) queue.Enqueue(childId);
                        }
                    }
                    catch { }
                }
            }
            return null;
        }

        public async Task<int?> GetStateAsync()
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            // try Monitoring CurrentState variable first
            try
            {
                var csv = CurrentStateVariable;
                if (csv != null && csv.Value != null)
                {
                    var v = csv.Value;
                    if (v is int vi) return vi;
                    if (v is uint vui) return (int)vui;
                    if (v is short s) return (int)s;
                    if (v is ushort us) return (int)us;
                    var name = v is LocalizedText lt ? lt.Text : v.ToString();
                    if (!string.IsNullOrEmpty(name) && Enum.IsDefined(typeof(Common.SkillStates), name))
                    {
                        try { var enumVal = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), name, true); return (int)enumVal; } catch { }
                    }
                }
            }
            catch { }

            NodeId? vid = _currentStateNode;
            if (vid == null)
            {
                vid = await FindVariableNodeRecursive(session, BaseNodeId, "CurrentState") ?? await FindVariableNodeRecursive(session, BaseNodeId, "State");
            }
            if (vid == null) return null;
            try
            {
                var dv = await session.ReadValueAsync(vid, System.Threading.CancellationToken.None);
                var val = dv?.Value;
                if (val == null)
                {
                    // try fallback locations
                    try
                    {
                        NodeId? fallback = null;
                        if (_currentStateNode != null)
                        {
                            fallback = await FindVariableNodeRecursive(session, _currentStateNode, "StateNumber") ?? await FindVariableNodeRecursive(session, _currentStateNode, "State");
                        }
                        if (fallback == null && _stateMachineNode != null)
                        {
                            fallback = await FindVariableNodeRecursive(session, _stateMachineNode, "StateNumber") ?? await FindVariableNodeRecursive(session, _stateMachineNode, "State");
                        }
                        if (fallback != null)
                        {
                            var dv2 = await session.ReadValueAsync(fallback, System.Threading.CancellationToken.None);
                            var v2 = dv2?.Value;
                            if (v2 is uint u2) return (int)u2;
                            if (v2 is int ii) return ii;
                            if (v2 is ushort us2) return (int)us2;
                            if (v2 is short s2) return (int)s2;
                            var name2 = v2 is LocalizedText lt2 ? lt2.Text : v2?.ToString();
                            if (!string.IsNullOrEmpty(name2))
                            {
                                try { var enumVal2 = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), name2, true); return (int)enumVal2; } catch { }
                            }
                        }
                        try
                        {
                            var node = await session.ReadNodeAsync(vid);
                            var disp = node?.DisplayName?.Text ?? node?.BrowseName?.Name;
                            if (!string.IsNullOrEmpty(disp))
                            {
                                try { var enumVal3 = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), disp, true); return (int)enumVal3; } catch { }
                            }
                        }
                        catch { }
                    }
                    catch { }

                    return null;
                }
                if (val is int i) return i;
                if (val is uint ui) return (int)ui;
                if (val is short s) return (int)s;
                if (val is ushort us) return (int)us;
                var name = val is LocalizedText ltx ? ltx.Text : val.ToString();
                if (!string.IsNullOrEmpty(name) && Enum.IsDefined(typeof(Common.SkillStates), name))
                {
                    try { var enumVal = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), name, true); return (int)enumVal; } catch { }
                }
            }
            catch { }
            return null;
        }

        /// <summary>
        /// Determine if skill is finite based on available states (contains 'Completed').
        /// Fallback to FinalResultData heuristic when available states are unknown.
        /// </summary>
        public bool IsFinite
        {
            get
            {
                if (_isFiniteHint.HasValue) return _isFiniteHint.Value;
                if (_availableStates != null && _availableStates.Count > 0)
                {
                    try { UAClient.Common.Log.Info($"RemoteSkill '{Name}': AvailableStates count={_availableStates.Count}"); } catch { }
                    foreach (var s in _availableStates)
                    {
                        if (string.Equals(s, "Completed", StringComparison.OrdinalIgnoreCase) ||
                            string.Equals(s, "Completing", StringComparison.OrdinalIgnoreCase))
                        {
                            return true;
                        }
                    }
                    return false;
                }
                try { UAClient.Common.Log.Info($"RemoteSkill '{Name}': AvailableStates unknown, FinalResultData.Count={FinalResultData?.Count ?? 0}"); } catch { }
                return FinalResultData != null && FinalResultData.Count > 0;
            }
        }

        private async Task<NodeId?> FindNodeByBrowseNameRecursive(Session session, NodeId startNode, string browseName)
        {
            // Try translate-based fast paths
            try
            {
                var t1 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { browseName }); if (t1 != null) return t1;
                var t2 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "SkillExecution", browseName }); if (t2 != null) return t2;
                var t3 = await SessionBrowseCache.TranslatePathAsync(session, startNode, new[] { "StateMachine", browseName }); if (t3 != null) return t3;
            }
            catch { }

            var browser = new Browser(session)
            {
                BrowseDirection = BrowseDirection.Forward,
                ReferenceTypeId = ReferenceTypeIds.HierarchicalReferences,
                NodeClassMask = (int)(NodeClass.Object | NodeClass.Variable | NodeClass.Method)
            };
            var queue = new Queue<NodeId>(); queue.Enqueue(startNode);
            while (queue.Count > 0)
            {
                var node = queue.Dequeue();
                ReferenceDescriptionCollection refs = null;
                try { refs = await browser.BrowseAsync(node); } catch { }
                if (refs == null) continue;
                foreach (var r in refs)
                {
                    try
                    {
                        if (r?.NodeId == null) continue;
                        var name = r.DisplayName?.Text ?? r.BrowseName?.Name;
                        var expanded = r.NodeId as ExpandedNodeId ?? new ExpandedNodeId(r.NodeId);
                        var childId = UaHelpers.ToNodeId(expanded, session);
                        if (childId == null) continue;
                        if (!string.IsNullOrEmpty(name) && string.Equals(name, browseName, StringComparison.OrdinalIgnoreCase)) return childId;
                        if (r.NodeClass == NodeClass.Object || r.NodeClass == NodeClass.Variable) queue.Enqueue(childId);
                    }
                    catch { }
                }
            }
            return null;
        }

        private async Task<NodeId?> GetTypeDefinitionAsync(Session session, NodeId nodeId)
        {
            try
            {
                var browser = new Browser(session)
                {
                    BrowseDirection = BrowseDirection.Forward,
                    ReferenceTypeId = ReferenceTypeIds.HasTypeDefinition,
                    IncludeSubtypes = true,
                    NodeClassMask = 0 // any
                };
                var refs = await browser.BrowseAsync(nodeId);
                if (refs != null && refs.Count > 0)
                {
                    var expanded = refs[0].NodeId as ExpandedNodeId ?? new ExpandedNodeId(refs[0].NodeId);
                    return UaHelpers.ToNodeId(expanded, session);
                }
            }
            catch { }
            return null;
        }

        private async Task<string?> GetBrowseNameAsync(Session session, NodeId nodeId)
        {
            try
            {
                var readValueIds = new ReadValueIdCollection { new ReadValueId { NodeId = nodeId, AttributeId = Attributes.BrowseName } };
                DataValueCollection results;
                DiagnosticInfoCollection diagnosticInfos;
                session.Read(null, 0, TimestampsToReturn.Neither, readValueIds, out results, out diagnosticInfos);
                if (results != null && results.Count > 0 && results[0].Value != null)
                {
                    var qn = results[0].Value as QualifiedName;
                    return qn?.Name;
                }
            }
            catch { }
            return null;
        }

        public override async Task SetupSubscriptionsAsync(SubscriptionManager subscriptionManager, bool createSubscriptions = false)
        {
            // allow base to collect FinalResultData (and optionally create subscriptions)
            await base.SetupSubscriptionsAsync(subscriptionManager, createSubscriptions);
            // after base call, an internal subscription manager may have been created
            var subMgr = subscriptionManager ?? _internalSubscriptionManager;
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");

            // Locate SkillExecution -> StateMachine -> CurrentState / AvailableStates; avoid expensive reads/subscriptions unless requested
            try
            {
                var skillExec = await FindNodeByBrowseNameRecursive(session, BaseNodeId, "SkillExecution");
                if (skillExec == null) return;
                var stateMachine = await FindNodeByBrowseNameRecursive(session, skillExec, "StateMachine");
                if (stateMachine == null) return;

                _stateMachineNode = stateMachine;
                _currentStateNode = await FindNodeByBrowseNameRecursive(session, stateMachine, "CurrentState");

                var avail = await FindNodeByBrowseNameRecursive(session, stateMachine, "AvailableStates");
                if (avail != null)
                {
                    try
                    {
                        var dv = await session.ReadValueAsync(avail, System.Threading.CancellationToken.None);
                        var val = dv.Value;
                        var list = new List<string>();
                        if (val is string[] sa) list.AddRange(sa);
                        else if (val is object[] oa) foreach (var o in oa) list.Add(o?.ToString() ?? "");
                        else if (val != null) list.Add(val.ToString() ?? "");
                        if (list.Count > 0) _availableStates = list;
                    }
                    catch { }
                }

                // determine skill type from TypeDefinition if possible (cheap browse)
                try
                {
                    var typeDef = await GetTypeDefinitionAsync(session, BaseNodeId);
                    if (typeDef != null)
                    {
                        var typeName = await GetBrowseNameAsync(session, typeDef);
                        if (!string.IsNullOrEmpty(typeName))
                        {
                            if (string.Equals(typeName, "FiniteSkillType", StringComparison.OrdinalIgnoreCase)) _isFiniteHint = true;
                            else if (string.Equals(typeName, "ContinuousSkillType", StringComparison.OrdinalIgnoreCase)) _isFiniteHint = false;
                        }
                    }
                }
                catch { }

                // If caller requested subscription creation, ensure subscription manager exists and subscribe to CurrentState
                if (createSubscriptions)
                {
                    if (subMgr == null)
                    {
                        try { subMgr = new SubscriptionManager(RemoteServerClient); _internalSubscriptionManager = subMgr; } catch { subMgr = null; }
                    }

                    if (_currentStateNode != null && subMgr != null)
                    {
                        try
                        {
                            // create RemoteVariable wrapper if missing
                            lock (_monitoring_nodes)
                            {
                                if (!_monitoring_nodes.ContainsKey(_currentStateNode))
                                {
                                    var rv = new RemoteVariable("CurrentState", _currentStateNode);
                                    rv.SetClient(RemoteServerClient);
                                    _monitoring_nodes[_currentStateNode] = rv;
                                    lock (Monitoring) { if (!Monitoring.ContainsKey("CurrentState")) Monitoring["CurrentState"] = rv; }
                                }
                            }

                            await subMgr.SubscribeDataChangeAsync(this, new[] { _currentStateNode });

                            // initialize cached state from a read (best-effort)
                            try
                            {
                                var cv = await session.ReadValueAsync(_currentStateNode, System.Threading.CancellationToken.None);
                                if (cv?.Value != null)
                                {
                                    var v = cv.Value;
                                    if (v is int vi && Enum.IsDefined(typeof(Common.SkillStates), vi)) _cachedState = (Common.SkillStates)vi;
                                    else if (v is uint vui) { var ii = (int)vui; if (Enum.IsDefined(typeof(Common.SkillStates), ii)) _cachedState = (Common.SkillStates)ii; }
                                    else { var s = v is LocalizedText ltx ? ltx.Text : v.ToString(); if (!string.IsNullOrEmpty(s)) { try { _cachedState = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), s, true); } catch { } } }
                                }
                            }
                            catch { }
                        }
                        catch { }
                    }
                }
            }
            catch { }
        }

        // Subscribe core monitoring variables (ensure CurrentState is subscribed even if not in Monitoring folder)
        public override async Task SubscribeCoreAsync(SubscriptionManager subscriptionManager)
        {
            if (subscriptionManager == null) return;
            // ensure base monitoring subscriptions (if any)
            await base.SubscribeCoreAsync(subscriptionManager);

            // If we already know the CurrentState node, ensure it's exposed as RemoteVariable and subscribed with this as handler
            try
            {
                var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
                if (_currentStateNode == null)
                {
                    // try to discover CurrentState under the state machine path
                    var potential = await FindVariableNodeRecursive(session, BaseNodeId, "CurrentState");
                    if (potential != null) _currentStateNode = potential;
                }

                if (_currentStateNode != null)
                {
                    lock (_monitoring_nodes)
                    {
                        if (!_monitoring_nodes.ContainsKey(_currentStateNode))
                        {
                            var rv = new RemoteVariable("CurrentState", _currentStateNode);
                            rv.SetClient(RemoteServerClient);
                            _monitoring_nodes[_currentStateNode] = rv;
                            lock (Monitoring)
                            {
                                if (!Monitoring.ContainsKey("CurrentState")) Monitoring["CurrentState"] = rv;
                            }
                        }
                        else
                        {
                            // ensure client set
                            try { _monitoring_nodes[_currentStateNode].SetClient(RemoteServerClient); } catch { }
                        }
                    }

                    try
                    {
                        await subscriptionManager.SubscribeDataChangeAsync(this, new[] { _currentStateNode });
                    }
                    catch
                    {
                        // fallback: subscribe the remote variable itself
                        try { await _monitoring_nodes[_currentStateNode].SetupSubscriptionAsync(subscriptionManager); } catch { }
                    }
                }
            }
            catch { }
        }

        public void AddStateSubscriber(Action<Common.SkillStates> callback)
        {
            if (callback == null) return;
            _stateSubscribers.Add(callback);
        }

        private void NotifyStateSubscribers(Common.SkillStates state)
        {
            foreach (var cb in _stateSubscribers)
            {
                try { cb(state); } catch { }
            }
        }

        public override void DataChangeNotification(NodeId nodeId, DataValue value, MonitoredItemNotificationEventArgs args)
        {
            try
            {
                if (_currentStateNode != null && nodeId != null && nodeId == _currentStateNode)
                {
                    // let base update monitoring variable mapping
                    base.DataChangeNotification(nodeId, value, args);

                    try
                    {
                        object? v = value?.Value;
                        Common.SkillStates? parsed = null;
                        if (v == null) { }
                        else if (v is int ii) { if (Enum.IsDefined(typeof(Common.SkillStates), ii)) parsed = (Common.SkillStates)ii; }
                        else if (v is uint uii) { var iival = (int)uii; if (Enum.IsDefined(typeof(Common.SkillStates), iival)) parsed = (Common.SkillStates)iival; }
                        else { var s = v is LocalizedText lt ? lt.Text : v.ToString(); if (!string.IsNullOrEmpty(s)) { try { parsed = (Common.SkillStates)Enum.Parse(typeof(Common.SkillStates), s, true); } catch { } } }

                        if (parsed != null && parsed.Value != _cachedState)
                        {
                            _cachedState = parsed.Value;
                            try { UAClient.Common.Log.Info($"RemoteSkill '{Name}': state changed -> {_cachedState}"); } catch { }
                            NotifyStateSubscribers(_cachedState);
                        }
                    }
                    catch { }
                    return;
                }
            }
            catch { }

            base.DataChangeNotification(nodeId, value, args);
        }

        private async Task<bool> WaitForStateWithSubscriptionAsync(Common.SkillStates desired, TimeSpan timeout)
        {
            // quick check
            if (_cachedState == desired) return true;
            try { await EnsureCoreSubscribedAsync(); } catch { }
            var tcs = new TaskCompletionSource<bool>(TaskCreationOptions.RunContinuationsAsynchronously);
            Action<Common.SkillStates> cb = null!;
            cb = (s) =>
            {
                try
                {
                    if (s == desired) tcs.TrySetResult(true);
                }
                catch { }
            };
            AddStateSubscriber(cb);
            try
            {
                // also check current state in case it changed before subscriber added
                if (_cachedState == desired) return true;
                var completed = await Task.WhenAny(tcs.Task, Task.Delay(timeout));
                return completed == tcs.Task && await tcs.Task;
            }
            finally
            {
                try { _stateSubscribers.Remove(cb); } catch { }
            }
        }

        public async Task<bool> WaitForStateAsync(Common.SkillStates desired, TimeSpan timeout)
        {
            var sw = System.Diagnostics.Stopwatch.StartNew();
            while (sw.Elapsed < timeout)
            {
                try
                {
                    var st = await GetStateAsync();
                    if (st != null && st == (int)desired) return true;
                }
                catch { }
                await Task.Delay(500);
            }
            return false;
        }

        public async Task StartAsync(params object[] inputs)
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            // Prefer cached Start method node id to avoid repeated searches
            NodeId? methodId = _startMethodNode;
            if (methodId == null)
            {
                methodId = await FindMethodNodeRecursive(session, BaseNodeId, "Start");
            }
            if (methodId == null) throw new InvalidOperationException("Start method not found for skill");
            await session.CallAsync(BaseNodeId, methodId, System.Threading.CancellationToken.None, inputs);
        }

        public async Task StopAsync()
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            var methodId = _stopMethodNode ?? await FindMethodNodeRecursive(session, BaseNodeId, "Stop");
            if (methodId == null) return;
            await session.CallAsync(BaseNodeId, methodId, System.Threading.CancellationToken.None);
        }

        public async Task AbortAsync()
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            var methodId = _abortMethodNode ?? await FindMethodNodeRecursive(session, BaseNodeId, "Abort");
            if (methodId == null) return;
            await session.CallAsync(BaseNodeId, methodId, System.Threading.CancellationToken.None);
        }

        public async Task<IDictionary<string, object?>> ExecuteAsync(IDictionary<string, object?>? parameters = null,
             bool waitForCompletion = true,
             bool resetAfterCompletion = true,
             bool resetBeforeIfHalted = true,
             TimeSpan? timeout = null)
        {
            var session = RemoteServerClient.Session ?? throw new InvalidOperationException("No session");
            timeout ??= TimeSpan.FromSeconds(30);

            var sw = Stopwatch.StartNew();
            UAClient.Common.Log.Info($"RemoteSkill '{Name}': ExecuteAsync start (waitForCompletion={waitForCompletion}, timeout={timeout})");

            // ensure lightweight discovery of skill nodes
            try { await SetupSubscriptionsAsync(_internalSubscriptionManager, false); } catch (Exception ex) { UAClient.Common.Log.Warn($"RemoteSkill '{Name}': SetupSubscriptionsAsync failed: {ex.Message}"); }

            // ensure core subscriptions (CurrentState etc.) are present before executing
            try { await EnsureCoreSubscribedAsync(); UAClient.Common.Log.Info($"RemoteSkill '{Name}': core subscribed={_coreSubscribed}"); } catch (Exception ex) { UAClient.Common.Log.Warn($"RemoteSkill '{Name}': EnsureCoreSubscribedAsync failed: {ex.Message}"); }

            // Write parameters
            if (parameters != null)
            {
                UAClient.Common.Log.Info($"RemoteSkill '{Name}': writing {parameters.Count} parameters");
                foreach (var kv in parameters)
                {
                    try
                    {
                        UAClient.Common.Log.Debug($"RemoteSkill '{Name}': write parameter {kv.Key} = {kv.Value}");
                        await WriteParameterAsync(kv.Key, kv.Value ?? "");
                    }
                    catch (Exception ex)
                    {
                        UAClient.Common.Log.Warn($"RemoteSkill '{Name}': WriteParameterAsync failed for {kv.Key}: {ex.Message}");
                    }
                }
            }

            // Check and handle pre-start states:
            try
            {
                var st = await GetStateAsync();
                // If skill is in Starting/Running/Completing, consider it already running and abort
                if (st == (int)Common.SkillStates.Starting || st == (int)Common.SkillStates.Running || st == (int)Common.SkillStates.Completing)
                {
                    throw new InvalidOperationException($"RemoteSkill '{Name}' is already running (state={st})");
                }

                // If skill is Halted, Completed or Suspended, reset it before starting if requested
                if ((st == (int)Common.SkillStates.Halted || st == (int)Common.SkillStates.Completed || st == (int)Common.SkillStates.Suspended) && resetBeforeIfHalted)
                {
                    try
                    {
                        var resetTarget = _stateMachineNode ?? BaseNodeId;
                        var resetMethod = _resetMethodNode ?? await FindMethodNodeRecursive(session, resetTarget, "Reset");
                        if (resetMethod != null)
                        {
                            UAClient.Common.Log.Info($"RemoteSkill '{Name}': resetting before start (state={st})");
                            await session.CallAsync(resetTarget, resetMethod, System.Threading.CancellationToken.None);
                            await WaitForStateWithSubscriptionAsync(Common.SkillStates.Ready, timeout.Value);
                        }
                    }
                    catch (Exception ex)
                    {
                        UAClient.Common.Log.Warn($"RemoteSkill '{Name}': Reset before start failed: {ex.Message}");
                        throw;
                    }
                }
                else if ((st == (int)Common.SkillStates.Halted || st == (int)Common.SkillStates.Completed || st == (int)Common.SkillStates.Suspended) && !resetBeforeIfHalted)
                {
                    UAClient.Common.Log.Info($"RemoteSkill '{Name}': not resetting before start (state={st}, resetBeforeIfHalted=false)");
                }
            }
            catch (InvalidOperationException)
            {
                // propagate running-state exception
                throw;
            }
            catch
            {
                // swallow other errors to preserve previous behaviour
            }

            var cur = await GetStateAsync();
            if (cur == null || cur != (int)Common.SkillStates.Ready) throw new InvalidOperationException($"RemoteSkill '{Name}' is not in Ready state (current={cur})");

            UAClient.Common.Log.Info($"RemoteSkill '{Name}': invoking Start");
            try { await StartAsync(); UAClient.Common.Log.Info($"RemoteSkill '{Name}': Start invoked"); } catch (Exception ex) { UAClient.Common.Log.Warn($"RemoteSkill '{Name}': StartAsync failed: {ex.Message}"); throw; }

            var runningOk = await WaitForStateWithSubscriptionAsync(Common.SkillStates.Running, TimeSpan.FromSeconds(10));
            UAClient.Common.Log.Info($"RemoteSkill '{Name}': awaited Running => {runningOk}");
            if (!runningOk)
            {
                try
                {
                    var cached = _cachedState;
                    var read = await GetStateAsync();
                    var csv = CurrentStateVariable?.Value;
                    UAClient.Common.Log.Warn($"RemoteSkill '{Name}': Running wait failed. cached={cached}, read={read}, csv={csv}");
                }
                catch { }
                throw new TimeoutException("Skill did not reach Running state after Start");
            }

            if (!waitForCompletion) { UAClient.Common.Log.Info($"RemoteSkill '{Name}': not waiting for completion, returning early (short delay)"); await Task.Delay(500); }

            if (waitForCompletion)
            {
                UAClient.Common.Log.Info($"RemoteSkill '{Name}': waiting for completion (IsFinite={IsFinite})");
                if (IsFinite) await WaitForStateWithSubscriptionAsync(Common.SkillStates.Completed, timeout.Value);
                else await WaitForStateWithSubscriptionAsync(Common.SkillStates.Halted, timeout.Value);
                UAClient.Common.Log.Info($"RemoteSkill '{Name}': completion wait finished. CurrentState={_cachedState}");
            }

            // Prefer values populated by subscriptions; fall back to reads
            var outDict = new Dictionary<string, object?>();
            if (FinalResultData != null)
            {
                foreach (var kv in FinalResultData)
                {
                    try
                    {
                        var rv = kv.Value;
                        if (rv != null && rv.Value != null) { outDict[kv.Key] = rv.Value; continue; }
                        var node = rv?.NodeId;
                        if (node == null) { outDict[kv.Key] = null; continue; }
                        var dv = await session.ReadValueAsync(node, System.Threading.CancellationToken.None);
                        outDict[kv.Key] = dv?.Value;
                    }
                    catch { outDict[kv.Key] = null; }
                }
                UAClient.Common.Log.Info($"RemoteSkill '{Name}': Read FinalResultData keys={outDict.Count}");
            }

            if (resetAfterCompletion)
            {
                try
                {
                    var resetTarget = _stateMachineNode ?? BaseNodeId;
                    var resetMethod = _resetMethodNode ?? await FindMethodNodeRecursive(session, resetTarget, "Reset");
                    if (resetMethod != null)
                    {
                        UAClient.Common.Log.Info($"RemoteSkill '{Name}': invoking Reset after completion");
                        await session.CallAsync(resetTarget, resetMethod, System.Threading.CancellationToken.None);
                        await WaitForStateWithSubscriptionAsync(Common.SkillStates.Ready, timeout.Value);
                        UAClient.Common.Log.Info($"RemoteSkill '{Name}': Reset completed");
                    }
                }
                catch { }
            }

            sw.Stop();
            UAClient.Common.Log.Info($"RemoteSkill '{Name}': ExecuteAsync finished in {sw.ElapsedMilliseconds} ms");
            return outDict;
        }

        // Ensure core subscriptions are created and cached for future use
        private async Task EnsureCoreSubscribedAsync()
        {
            // fast path
            if (_coreSubscribed) return;
            // ensure only one creator
            lock (_coreSubLock)
            {
                if (_coreSubscribed) return;
                // mark tentatively to prevent re-entry; actual subscribe happens outside lock
            }

            SubscriptionManager? subMgr = _remoteServer?.SubscriptionManager ?? _internalSubscriptionManager;
            if (subMgr == null)
            {
                try
                {
                    subMgr = new SubscriptionManager(RemoteServerClient);
                    _internalSubscriptionManager = subMgr;
                }
                catch { subMgr = null; }
            }

            if (subMgr != null)
            {
                try
                {
                    await SubscribeCoreAsync(subMgr);
                }
                catch { }
            }

            // log initial state after subscribing
            try
            {
                var initial = await GetStateAsync();
                try { UAClient.Common.Log.Info($"RemoteSkill '{Name}': initial state after core subscribe = {initial}"); } catch { }
            }
            catch { }

            // finalize flag
            lock (_coreSubLock)
            {
                _coreSubscribed = true;
            }
        }
    }
}
