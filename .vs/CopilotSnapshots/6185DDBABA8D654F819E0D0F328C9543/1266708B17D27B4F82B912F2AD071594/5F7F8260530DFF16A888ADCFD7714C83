using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using Opc.Ua;

namespace UAClient.Client
{
    public class RemotePort : RemoteComponent
    {
        public RemoteModule? Module { get; }

        public RemotePort(string name, NodeId baseNodeId, UaClient client, RemoteServer remoteServer, RemoteModule? module = null)
            : base(name, baseNodeId, client, remoteServer)
        {
            Module = module;
        }

        // CurrentState exposes the component's monitoring CurrentState if present
        public object? CurrentState
        {
            get
            {
                if (Monitoring.TryGetValue("CurrentState", out var stateVar)) return stateVar.Value;
                if (Monitoring.TryGetValue("State", out var altStateVar)) return altStateVar.Value;
                return null;
            }
        }

        // Convenience properties (mirrors Python RemotePort) backed by RemoteComponent's Attributes/Monitoring
        public bool ActivePort
        {
            get
            {
                if (Attributes.TryGetValue("IsActive", out var rv) && rv?.Value is bool b) return b;
                return false;
            }
        }

        public string? OwnRfidTag
        {
            get
            {
                if (Attributes.TryGetValue("OwnRfidTag", out var rv) && rv?.Value != null) return rv.Value.ToString();
                return null;
            }
        }

        public string? PartnerRfidTag
        {
            get
            {
                if (Monitoring.TryGetValue("PartnerRfidTag", out var rv) && rv?.Value != null) return rv.Value.ToString();
                return null;
            }
        }

        public bool Closed
        {
            get
            {
                if (Monitoring.TryGetValue("MagnetsClosed", out var rv) && rv?.Value is bool b) return b;
                return false;
            }
        }

        public string Type => "Port";

        public async Task<bool> IsCoupledAsync(UaClient client)
        {
            // Prefer couple skill state when available
            try
            {
                // check local SkillSet first
                if (SkillSet.TryGetValue("CoupleSkill", out var localSkill))
                {
                    UAClient.Common.Log.Debug($"RemotePort '{Name}': IsCoupledAsync: found CoupleSkill in SkillSet");
                    var st = await localSkill.GetStateAsync();
                    UAClient.Common.Log.Debug($"RemotePort '{Name}': IsCoupledAsync: localSkill state={st}");
                    return st != null && st == (int)UAClient.Common.SkillStates.Running;
                }
                // fallback to module-wide methods/skills
                if (Module != null)
                {
                    foreach (var kv in Module.Methods)
                    {
                        if (kv.Value is RemoteSkill rs && string.Equals(rs.Name, "CoupleSkill", StringComparison.OrdinalIgnoreCase))
                        {
                            UAClient.Common.Log.Debug($"RemotePort '{Name}': IsCoupledAsync: found CoupleSkill on Module.Methods");
                            var st = await rs.GetStateAsync();
                            UAClient.Common.Log.Debug($"RemotePort '{Name}': IsCoupledAsync: module couple state={st}");
                            return st != null && st == (int)UAClient.Common.SkillStates.Running;
                        }
                    }
                }
                // final passive fallback: if no couple skill exists, infer coupling from PartnerRfidTag presence
                try
                {
                    var tag = PartnerRfidTag;
                    UAClient.Common.Log.Debug($"RemotePort '{Name}': IsCoupledAsync: no CoupleSkill found, PartnerRfidTag={tag}");
                    return !string.IsNullOrEmpty(tag);
                }
                catch { }
            }
            catch { }
            return false;
        }

        public async Task CoupleAsync(UaClient client, TimeSpan? timeout = null)
        {
            timeout ??= TimeSpan.FromSeconds(30);
            if (Module == null) return;

            // find couple skill on this component (prefer local SkillSet)
            RemoteSkill? couple = null;
            if (SkillSet.TryGetValue("CoupleSkill", out var localSkill)) couple = localSkill;
            // fallback: look for a couple skill stored in compatibility Methods map on the port
            if (couple == null)
            {
                foreach (var kv in Methods)
                {
                    if (kv.Value is RemoteSkill rs && string.Equals(rs.Name, "CoupleSkill", StringComparison.OrdinalIgnoreCase))
                    {
                        couple = rs;
                        break;
                    }
                }
            }
            // fallback: look on module
            if (couple == null && Module != null)
            {
                foreach (var kv in Module.Methods)
                {
                    if (kv.Value is RemoteSkill rs && string.Equals(rs.Name, "CoupleSkill", StringComparison.OrdinalIgnoreCase))
                    {
                        couple = rs;
                        break;
                    }
                }
            }
            if (couple == null)
            {
                // passive port, nothing to do — add diagnostics to help identify why no couple skill found
                try
                {
                    UAClient.Common.Log.Info($"RemotePort '{Name}': no CoupleSkill found on port or module; treating as passive port");
                    UAClient.Common.Log.Debug($"RemotePort '{Name}': ActivePort={ActivePort}, OwnRfidTag={OwnRfidTag}, PartnerRfidTag={PartnerRfidTag}");
                    try { UAClient.Common.Log.Debug($"RemotePort '{Name}': SkillSet keys={string.Join(',', SkillSet.Keys)}"); } catch { }
                    try { UAClient.Common.Log.Debug($"RemotePort '{Name}': Port Methods keys={string.Join(',', Methods.Keys)}"); } catch { }
                    if (Module != null)
                    {
                        try { UAClient.Common.Log.Debug($"RemotePort '{Name}': Module.Methods keys={string.Join(',', Module.Methods.Keys)}"); } catch { }
                        try { UAClient.Common.Log.Debug($"RemotePort '{Name}': Module.SkillSet keys={string.Join(',', Module.SkillSet.Keys)}"); } catch { }
                    }
                }
                catch { }
                return;
            }

            UAClient.Common.Log.Info($"RemotePort '{Name}': CoupleAsync: using CoupleSkill '{couple.Name}' (BaseNodeId={couple.BaseNodeId})");
            try
            {
                var st = await couple.GetStateAsync();
                // If the couple skill is already running, warn and return
                if (st == (int)UAClient.Common.SkillStates.Running)
                {
                    UAClient.Common.Log.Warn($"RemotePort '{Name}': CoupleSkill already running, skipping coupling");
                    return;
                }

                if (st == (int)UAClient.Common.SkillStates.Halted)
                {
                    try
                    {
                        // call Reset on the couple skill (will use its Execute/Reset logic)
                        // prefer cached reset method if available
                        var resetMethod = couple.ResetMethodNode ?? await couple.FindMethodNodeRecursive(client.Session, couple.BaseNodeId, "Reset");
                        if (resetMethod != null)
                        {
                            // prefer calling Reset on the state machine node if available
                            var obj = couple.StateMachineNode ?? couple.BaseNodeId;
                            await client.Session.CallAsync(obj, resetMethod, System.Threading.CancellationToken.None);
                            await couple.WaitForStateAsync(UAClient.Common.SkillStates.Ready, timeout.Value);
                        }
                    }
                    catch { }
                }
            }
            catch { }

            // if not coupled, start the couple skill. If Start fails with BadInvalidState, try Reset then Start again.
            try
            {
                var coupled = await IsCoupledAsync(client);
                if (!coupled)
                {
                    try
                    {
                        UAClient.Common.Log.Info($"RemotePort '{Name}': invoking Start on CoupleSkill '{couple.Name}'");
                        await couple.StartAsync();
                        UAClient.Common.Log.Info($"RemotePort '{Name}': Start invoked on CoupleSkill, waiting for Running");
                        await couple.WaitForStateAsync(UAClient.Common.SkillStates.Running, timeout.Value);
                        UAClient.Common.Log.Info($"RemotePort '{Name}': CoupleSkill reached Running");
                    }
                    catch (Opc.Ua.ServiceResultException sre) when (sre.StatusCode == StatusCodes.BadInvalidState)
                    {
                        UAClient.Common.Log.Info($"RemotePort '{Name}': Couple start failed with BadInvalidState, attempting Reset then retry");
                        try
                        {
                            var resetTarget = couple.StateMachineNode ?? couple.BaseNodeId;
                            var resetMethod = await couple.FindMethodNodeRecursive(client.Session, resetTarget, "Reset")
                                              ?? await couple.FindMethodNodeRecursive(client.Session, couple.BaseNodeId, "Reset");
                            if (resetMethod != null)
                            {
                                try
                                {
                                    UAClient.Common.Log.Info($"RemotePort '{Name}': calling Reset on CoupleSkill (target={resetTarget})");
                                    await client.Session.CallAsync(resetTarget, resetMethod, System.Threading.CancellationToken.None);
                                }
                                catch (Exception ex)
                                {
                                    UAClient.Common.Log.Warn($"RemotePort '{Name}': Reset call failed: {ex.Message}");
                                }
                                await couple.WaitForStateAsync(UAClient.Common.SkillStates.Ready, TimeSpan.FromSeconds(10));
                                // retry start
                                UAClient.Common.Log.Info($"RemotePort '{Name}': retrying Start on CoupleSkill '{couple.Name}'");
                                await couple.StartAsync();
                                await couple.WaitForStateAsync(UAClient.Common.SkillStates.Running, timeout.Value);
                            }
                            else
                            {
                                UAClient.Common.Log.Warn($"RemotePort '{Name}': Reset method not found for CoupleSkill, cannot recover from BadInvalidState");
                            }
                        }
                        catch (Exception ex)
                        {
                            UAClient.Common.Log.Warn($"RemotePort '{Name}': Reset+retry failed: {ex.Message}");
                        }
                    }
                    catch (Exception ex)
                    {
                        UAClient.Common.Log.Warn($"RemotePort '{Name}': Couple Start failed: {ex.Message}");
                    }
                }
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"RemotePort '{Name}': couple failed: {ex.Message}");
            }
        }

        public async Task UncoupleAsync(UaClient client, TimeSpan? timeout = null)
        {
            timeout ??= TimeSpan.FromSeconds(30);
            if (Module == null) return;

            RemoteSkill? couple = null;
            foreach (var kv in Module.Methods)
            {
                if (kv.Value is RemoteSkill rs && string.Equals(rs.Name, "CoupleSkill", StringComparison.OrdinalIgnoreCase))
                {
                    couple = rs;
                    break;
                }
            }
            if (couple == null) return;

            try
            {
                await couple.StopAsync();
                await couple.WaitForStateAsync(UAClient.Common.SkillStates.Halted, timeout.Value);
                var resetMethod = await couple.FindMethodNodeRecursive(client.Session, couple.BaseNodeId, "Reset");
                if (resetMethod != null)
                {
                    var obj = couple.StateMachineNode ?? couple.BaseNodeId;
                    await client.Session.CallAsync(obj, resetMethod, System.Threading.CancellationToken.None);
                    await couple.WaitForStateAsync(UAClient.Common.SkillStates.Ready, timeout.Value);
                }
            }
            catch (Exception ex)
            {
                UAClient.Common.Log.Warn($"RemotePort '{Name}': uncouple failed: {ex.Message}");
            }
        }

        // Ensure subscriptions for port variables and attached methods/skills
        public async Task SetupSubscriptionsAsync(SubscriptionManager? subscriptionManager)
        {
            // always create a SubscriptionManager when none provided
            if (subscriptionManager == null)
            {
                try { subscriptionManager = new SubscriptionManager(RemoteModuleHelper.GetUaClientFromModule(Module)); }
                catch { subscriptionManager = null; }
            }

            // subscribe attached methods/skills
            foreach (var m in Methods.Values)
            {
                try { await m.SetupSubscriptionsAsync(subscriptionManager, true); } catch { }
            }

            // subscribe port variables
            if (subscriptionManager != null)
            {
                foreach (var rv in Variables.Values)
                {
                    try { await rv.SetupSubscriptionAsync(subscriptionManager); } catch { }
                }
            }
        }

        // Compatibility wrappers expected by RemoteModule discovery code
        public IDictionary<string, RemoteVariable> Variables => Attributes;
        public IDictionary<NodeId, RemoteVariable> NodeMap => _attribute_nodes;

        // Methods container used by discovery code (skills/methods attached to this port)
        public IDictionary<string, BaseRemoteCallable> Methods { get; } = new Dictionary<string, BaseRemoteCallable>(StringComparer.OrdinalIgnoreCase);
        public IDictionary<NodeId, BaseRemoteCallable> MethodsNodeMap { get; } = new Dictionary<NodeId, BaseRemoteCallable>();
    }

    internal static class RemoteModuleHelper
    {
        public static UaClient? GetUaClientFromModule(RemoteModule? module)
        {
            return module == null ? null : (module.GetType().GetField("_client", System.Reflection.BindingFlags.NonPublic | System.Reflection.BindingFlags.Instance)?.GetValue(module) as UaClient);
        }
    }
}
